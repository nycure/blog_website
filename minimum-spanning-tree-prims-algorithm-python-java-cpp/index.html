<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minimum Spanning Tree with Prim's Algorithm: Python, Java & C++
</title>

    <!-- Canonical URL -->
    <link rel="canonical" href="https://analyticsdrive.tech/minimum-spanning-tree-prims-algorithm-python-java-cpp/" />

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="https://analyticsdrive.tech/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://analyticsdrive.tech/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://analyticsdrive.tech/favicon-16x16.png">
    <link rel="manifest" href="https://analyticsdrive.tech/site.webmanifest">
    <link rel="icon" href="https://analyticsdrive.tech/favicon.ico" type="image/x-icon" />

    <!-- RSS Feed -->
    <link rel="alternate" type="application/atom+xml" title="Analytics Drive Atom Feed"
        href="https://analyticsdrive.tech/feeds/all.atom.xml" />

    <!-- SEO Meta Tags -->
    <meta name="description" content="Master the minimum spanning tree using Prim's algorithm in Python, Java, and C++. This tutorial guides you through implementation, concepts, and..." />
    <meta name="keywords" content="Breaking news, live coverage, investigations, analysis, photos ,opinions, Analytics Drive" />
    <meta name="author" content="Analytics Drive" />

    <!-- Open Graph -->
    <meta property="og:title" content="Minimum Spanning Tree with Prim's Algorithm: Python, Java & C++" />
    <meta property="og:description"
        content="Master the minimum spanning tree using Prim's algorithm in Python, Java, and C++. This tutorial guides you through implementation, concepts, and..." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://analyticsdrive.tech/minimum-spanning-tree-prims-algorithm-python-java-cpp/index.html" />
    <meta property="og:image" content="https://analyticsdrive.tech/images/minimum-spanning-tree-prims-algorithm-python-java-cpp-hero.webp" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@analyticsdrive" />
    <meta name="twitter:title" content="Minimum Spanning Tree with Prim's Algorithm: Python, Java & C++" />
    <meta name="twitter:description" content="Master the minimum spanning tree using Prim's algorithm in Python, Java, and C++. This tutorial guides you through implementation, concepts, and..." />
    <meta name="twitter:image" content="https://analyticsdrive.tech/images/minimum-spanning-tree-prims-algorithm-python-java-cpp-hero.webp" />


    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-P1LT4885S9"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-P1LT4885S9');
    </script>

    <!-- Schema.org JSON-LD -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "Analytics Drive",
      "url": "https://analyticsdrive.tech",
      "potentialAction": {
        "@type": "SearchAction",
        "target": "https://analyticsdrive.tech/search.html?q={search_term_string}",
        "query-input": "required name=search_term_string"
      }
    }
    </script>
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "Analytics Drive",
      "url": "https://analyticsdrive.tech",
      "logo": "https://analyticsdrive.tech/theme/images/logo.png",
      "sameAs": [
        "https://twitter.com/analyticsdrive",        "https://www.facebook.com/profile.php?id=61588072082428",        "https://www.instagram.com/analyticsdrive",        "https://www.reddit.com/r/Analyticsdrive/"      ]
    }
    </script>

    <!-- CSS -->
    <style>
        /* 
 * THE ANALYTICS POST - NEWSPAPER THEME
 * (c) 2026 - Classic Journalism Aesthetic
 */

        :root {
            /* Colors */
            --bg-paper: #ffffff;
            --text-ink: #2a2a2a;
            --text-muted: #666;
            --border-line: #e0e0e0;
            --accent: #000;
            /* Classic Black */
            --link-color: #005b96;
            /* Classic Blue */

            /* Typography */
            --font-masthead: 'UnifrakturMaguntia', cursive;
            --font-headline: 'Playfair Display', serif;
            --font-body: 'Libre Baskerville', serif;
            --font-ui: 'Libre Franklin', sans-serif;

            /* Layout */
            --max-width: 1100px;
            --spacing: 2rem;

            /* Component Specific */
            --bg-footer: #f9f9f9;
            --text-summary: #444444;
        }

        /* Dark Mode Overrides */
        [data-theme="dark"] {
            --bg-paper: #121212;
            --text-ink: #e0e0e0;
            --text-muted: #a0a0a0;
            --border-line: #333333;
            --accent: #ffffff;
            --link-color: #64b5f6;

            /* Component Override */
            --bg-footer: #1e1e1e;
            --text-summary: #d0d0d0;
        }

        /* Base */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--bg-paper);
            color: var(--text-ink);
            font-family: var(--font-body);
            font-size: 1.125rem;
            line-height: 1.8;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
            transition: 0.2s ease;
        }

        a:hover {
            text-decoration: underline;
            color: #003366;
        }

        /* Layout Container */
        .container {
            max-width: var(--max-width);
            margin: 0 auto;
            padding: 0 var(--spacing);
        }

        /* Header / Masthead */
        .site-header {
            padding: 2rem 0 1rem;
            margin-bottom: 2rem;
            text-align: center;
            border-bottom: 1px solid var(--accent);
            position: relative;
            /* Anchor for absolute positioned elements */
            z-index: 100;
        }

        .site-header .logo {
            font-family: var(--font-masthead);
            font-size: 4rem;
            color: var(--accent);
            text-decoration: none;
            display: block;
            margin-bottom: 1rem;
            line-height: 1;
        }



        .site-header .logo .dot {
            display: none;
            /* Hide the modern dot */
        }

        /* Navigation */
        .main-nav {
            border-top: 1px solid var(--border-line);
            border-bottom: 3px double var(--border-line);
            padding: 0.75rem 0;
            position: relative;
            /* Anchor for toggle button */
        }

        .main-nav ul {
            list-style: none;
            display: flex;
            justify-content: center;
            gap: 2rem;
            font-family: var(--font-ui);
            text-transform: uppercase;
            font-size: 0.85rem;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .main-nav a {
            color: var(--text-ink);
            text-decoration: none;
        }

        .main-nav a:hover {
            color: #555;
            text-decoration: underline;
        }

        /* Theme Toggle (Integrated in Nav) */
        .theme-toggle {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-ink);
            font-size: 1.25rem;
            padding: 0.5rem;
            z-index: 100;
            transition: transform 0.3s ease;
        }

        .theme-toggle:hover {
            transform: translateY(-50%) rotate(15deg);
        }

        /* Hero Section (Top Story) */
        .hero {
            text-align: center;
            padding: 3rem 0;
            border-bottom: 1px solid var(--border-line);
            margin-bottom: 3rem;
        }

        .hero h1 {
            font-family: var(--font-headline);
            font-size: 3.5rem;
            font-weight: 700;
            line-height: 1.1;
            margin-bottom: 1rem;
            color: var(--accent);
        }

        .hero p {
            font-family: var(--font-body);
            font-style: italic;
            color: var(--text-muted);
            font-size: 1.25rem;
            max-width: 700px;
            margin: 0 auto;
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 3rem 0;
            font-family: var(--font-ui);
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }

        .pagination a {
            padding: 0.5rem 1.5rem;
            border: 1px solid var(--border-line);
            color: var(--text-ink);
            transition: 0.2s;
        }

        .pagination a:hover {
            background: var(--accent);
            color: #fff;
            text-decoration: none;
            border-color: var(--accent);
        }

        /* Post Grid (Masonry / Columns) */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 2rem;
            padding-bottom: 4rem;
        }

        .post-card {
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--border-line);
        }

        /* Remove CSS Grid lines for a cleaner look, stick to bottom borders */

        .post-meta {
            font-family: var(--font-ui);
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 0.5rem;
            display: block;
        }

        .post-meta .category a {
            color: #d00;
            /* Red for category like 'Politics', 'Sports' */
            font-weight: 700;
            text-decoration: none;
        }

        .post-card h3 {
            font-family: var(--font-headline);
            font-size: 1.75rem;
            line-height: 1.2;
            margin-bottom: 1rem;
        }

        .post-card h3 a {
            color: var(--accent);
            text-decoration: none;
        }

        .post-card h3 a:hover {
            color: #444;
            text-decoration: none;
            /* Already handled by color change */
        }


        .post-card p {
            color: var(--text-summary);
            font-size: 1rem;
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        .read-more {
            font-family: var(--font-ui);
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--link-color);
        }

        /* Article Page */
        .single-post header {
            text-align: center;
            margin-bottom: 3rem;
            border-bottom: 1px solid var(--border-line);
            padding-bottom: 2rem;
        }

        .single-post h1 {
            font-family: var(--font-headline);
            font-size: 3rem;
            line-height: 1.1;
            margin-bottom: 1rem;
        }

        .single-post .post-meta {
            font-size: 1rem;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Featured Image (Article Page) */
        .featured-image {
            max-width: 740px;
            margin: 0 auto 2rem auto;
            border-radius: 12px;
            overflow: hidden;
        }

        .featured-image img {
            width: 100%;
            height: auto;
            display: block;
        }

        /* Post Card Thumbnail (Homepage) */
        .post-card-image {
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 0.75rem;
        }

        .post-card-image img {
            width: 100%;
            height: 180px;
            object-fit: cover;
            display: block;
            transition: transform 0.3s ease;
        }

        .post-card:hover .post-card-image img {
            transform: scale(1.05);
        }

        .post-content {
            max-width: 740px;
            /* Standard reading width */
            margin: 0 auto;
            font-size: 1.2rem;
            border: none;
            padding: 0;
            box-shadow: none;
            background: transparent;
        }

        /* Drop Cap for first paragraph */
        .post-content>p:first-of-type::first-letter {
            float: left;
            font-family: var(--font-headline);
            font-size: 4.5rem;
            line-height: 0.8;
            padding-right: 12px;
            padding-top: 4px;
            color: var(--accent);
        }

        .post-content h2,
        .post-content h3 {
            font-family: var(--font-headline);
            color: var(--accent);
            margin-top: 2.5rem;
            margin-bottom: 1rem;
        }

        .post-content p {
            margin-bottom: 1.5rem;
            color: var(--text-ink);
        }

        /* =============================================
           SYNTAX HIGHLIGHTING â€” One Dark (Pygments)
           ============================================= */

        /* Dark code block â€” works with or without .highlight wrapper */
        .post-content pre {
            background: #282C34;
            border-left: 4px solid #61AFEF;
            border-radius: 6px;
            margin: 2rem 0;
            padding: 1.25rem 1.5rem;
            overflow-x: auto;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #ABB2BF;
            font-family: 'Fira Code', 'Cascadia Code', 'Courier New', monospace;
        }

        /* Reset code inside pre â€” don't let inline-code styles bleed in */
        .post-content pre code {
            background: transparent;
            color: #ABB2BF;
            padding: 0;
            border-radius: 0;
            font-size: inherit;
            font-family: inherit;
        }

        /* Inline code (not in a block) */
        .post-content code {
            font-family: 'Fira Code', 'Cascadia Code', 'Courier New', monospace;
            color: #E06C75;
            background: rgba(40, 44, 52, 0.08);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.88em;
        }

        /* Dark mode: inline code */
        [data-theme="dark"] .post-content code {
            background: rgba(97, 175, 239, 0.1);
            color: #E06C75;
        }

        /* Also support .highlight wrapper if Pygments generates it */
        .post-content .highlight {
            background: #282C34;
            border-left: 4px solid #61AFEF;
            border-radius: 6px;
            margin: 2rem 0;
            overflow-x: auto;
        }

        .post-content .highlight pre {
            background: transparent;
            border: none;
            margin: 0;
        }

        /* â”€â”€ Pygments One Dark Token Colors â”€â”€
           Targets spans directly inside pre (Pelican 4.x structure)
           AND inside .highlight wrapper (fallback) */

        /* Comments â€” grey */
        .post-content pre .c,
        .post-content pre .ch,
        .post-content pre .cm,
        .post-content pre .cp,
        .post-content pre .c1,
        .post-content pre .cs,
        .post-content pre .cpf,
        .highlight .c,
        .highlight .ch,
        .highlight .cm,
        .highlight .cp,
        .highlight .c1,
        .highlight .cs {
            color: #7F848E;
        }

        /* Keywords â€” purple */
        .post-content pre .k,
        .post-content pre .kd,
        .post-content pre .kn,
        .post-content pre .kp,
        .post-content pre .kr,
        .highlight .k,
        .highlight .kd,
        .highlight .kn,
        .highlight .kp,
        .highlight .kr {
            color: #C678DD;
        }

        /* Keyword constants & types â€” yellow */
        .post-content pre .kc,
        .post-content pre .kt,
        .post-content pre .nb,
        .post-content pre .nc,
        .post-content pre .bp,
        .highlight .kc,
        .highlight .kt,
        .highlight .nb,
        .highlight .nc,
        .highlight .bp {
            color: #E5C07B;
        }

        /* Strings â€” green */
        .post-content pre .s,
        .post-content pre .s1,
        .post-content pre .s2,
        .post-content pre .sa,
        .post-content pre .sb,
        .post-content pre .sc,
        .post-content pre .sd,
        .post-content pre .se,
        .post-content pre .sh,
        .post-content pre .si,
        .post-content pre .sr,
        .post-content pre .ss,
        .post-content pre .sx,
        .highlight .s,
        .highlight .s1,
        .highlight .s2,
        .highlight .sa,
        .highlight .sb,
        .highlight .sc,
        .highlight .sd,
        .highlight .se,
        .highlight .sh,
        .highlight .si,
        .highlight .sr,
        .highlight .ss,
        .highlight .sx {
            color: #98C379;
        }

        /* Numbers â€” orange */
        .post-content pre .m,
        .post-content pre .mb,
        .post-content pre .mf,
        .post-content pre .mh,
        .post-content pre .mi,
        .post-content pre .mo,
        .post-content pre .il,
        .highlight .m,
        .highlight .mb,
        .highlight .mf,
        .highlight .mh,
        .highlight .mi,
        .highlight .mo,
        .highlight .il {
            color: #D19A66;
        }

        /* Functions & decorators â€” blue */
        .post-content pre .nf,
        .post-content pre .nd,
        .post-content pre .fm,
        .highlight .nf,
        .highlight .nd,
        .highlight .fm {
            color: #61AFEF;
            font-weight: bold;
        }

        /* Operators â€” cyan */
        .post-content pre .o,
        .post-content pre .ow,
        .highlight .o,
        .highlight .ow {
            color: #56B6C2;
        }

        /* Names / variables / tags â€” red-pink */
        .post-content pre .n,
        .post-content pre .na,
        .post-content pre .ni,
        .post-content pre .nl,
        .post-content pre .nn,
        .post-content pre .no,
        .post-content pre .nt,
        .post-content pre .nv,
        .post-content pre .nx,
        .post-content pre .ne,
        .post-content pre .vc,
        .post-content pre .vg,
        .post-content pre .vi,
        .post-content pre .vm,
        .highlight .na,
        .highlight .ni,
        .highlight .no,
        .highlight .nt,
        .highlight .nv,
        .highlight .ne,
        .highlight .vc,
        .highlight .vg,
        .highlight .vi {
            color: #E06C75;
        }

        /* Punctuation & whitespace â€” default text color */
        .post-content pre .p,
        .post-content pre .w,
        .highlight .p,
        .highlight .w {
            color: #ABB2BF;
        }

        /* Highlighted line background */
        .post-content pre .hll,
        .highlight .hll {
            background-color: #3E4451;
        }

        /* Errors */
        .post-content pre .err,
        .highlight .err {
            color: #ABB2BF;
        }

        /* Footer Meta */
        .article-footer-meta {
            max-width: 740px;
            margin: 4rem auto 0;
            border-top: 4px solid var(--accent);
            /* Thick end line */
            padding-top: 2rem;
        }

        .article-footer-meta strong {
            color: var(--accent);
        }

        .tag {
            background: #f0f0f0;
            color: #333;
            border: 1px solid #ddd;
        }

        .tag:hover {
            background: #000;
            color: #fff;
        }

        /* Site Footer */
        .site-footer {
            margin-top: 5rem;
            border-top: 1px solid var(--accent);
            padding: 3rem 0;
            background: var(--bg-footer);
            text-align: center;
            font-family: var(--font-ui);
            font-size: 0.9rem;
        }

        .social-links {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .site-header .logo {
                font-size: 2.5rem;
            }

            .hero h1 {
                font-size: 2.5rem;
            }

            .single-post h1 {
                font-size: 2.25rem;
            }

            /* Mobile Nav Fix */
            .main-nav {
                display: flex;
                justify-content: center;
                /* Center links only */
                align-items: center;
                padding: 0.5rem 1rem;
                position: static;
                /* Let absolute children be relative to .site-header */
            }

            .main-nav ul {
                flex: 1;
                justify-content: center;
                gap: 1rem;
                padding: 0;
                margin: 0;
            }

            .theme-toggle {
                position: absolute;
                /* Relative to .site-header */
                top: 1rem;
                right: 1rem;
                transform: none;
                margin-left: 0;
            }

            .theme-toggle:hover {
                transform: rotate(15deg);
            }
        }
    </style>
    <!-- Optimized Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preload" as="style"
        href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Libre+Franklin:wght@300;500;700&family=Playfair+Display:ital,wght@0,400..900;1,400..900&family=UnifrakturMaguntia&display=swap">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Libre+Franklin:wght@300;500;700&family=Playfair+Display:ital,wght@0,400..900;1,400..900&family=UnifrakturMaguntia&display=swap"
        media="print" onload="this.media='all'">
    <noscript>
        <link rel="stylesheet"
            href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Libre+Franklin:wght@300;500;700&family=Playfair+Display:ital,wght@0,400..900;1,400..900&family=UnifrakturMaguntia&display=swap">
    </noscript>
</head>

<body>
    <header class="site-header">
        <a href="https://analyticsdrive.tech/" class="logo">Analytics Drive<span class="dot">.</span></a>
        <nav class="main-nav">
            <ul>
                <li><a href="https://analyticsdrive.tech/">Home</a></li>
                <li><a href="https://analyticsdrive.tech/archives.html">Archives</a></li>
                <li><a href="https://analyticsdrive.tech/categories.html">Categories</a></li>
                <li><a href="https://analyticsdrive.tech/about/">About</a></li>
            </ul>
            <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Dark Mode">
                <span id="theme-icon">ðŸŒ™</span>
            </button>
        </nav>
        </div>
    </header>


    <main class="container content-wrapper">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "NewsArticle",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://analyticsdrive.tech/minimum-spanning-tree-prims-algorithm-python-java-cpp/"
  },
  "headline": "Minimum Spanning Tree with Prim's Algorithm: Python, Java & C++",
  "description": "Master the minimum spanning tree using Prim's algorithm in Python, Java, and C++. This tutorial guides you through implementation, concepts, and...",
  "image": [
    "https://analyticsdrive.tech/images/minimum-spanning-tree-prims-algorithm-python-java-cpp-hero.webp"
  ],
  "datePublished": "2026-02-27T12:27:00+00:00",
  "dateModified": "2026-02-27T12:27:00+00:00",
  "author": {
    "@type": "Person",
    "name": "Admin",
    "url": "https://analyticsdrive.tech/author/admin.html"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Analytics Drive",
    "logo": {
      "@type": "ImageObject",
      "url": "https://analyticsdrive.tech/favicon.ico"
    }
  }
}
</script>


<div class="post-layout">

  <!-- Floating Sticky Share Sidebar (desktop only) -->
  <aside class="share-sidebar" aria-label="Share this article">
    <span class="share-sidebar__label">Share</span>

    <!-- X (Twitter) -->
    <a href="https://twitter.com/intent/tweet?url=https://analyticsdrive.tech/minimum-spanning-tree-prims-algorithm-python-java-cpp/&text=Minimum%20Spanning%20Tree%20with%20Prim%27s%20Algorithm%3A%20Python%2C%20Java%20%26%20C%2B%2B"
      target="_blank" rel="noopener noreferrer" class="share-sidebar__btn share-sidebar__btn--twitter"
      aria-label="Share on X">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
        <path
          d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
      </svg>
    </a>

    <!-- Facebook -->
    <a href="https://www.facebook.com/sharer/sharer.php?u=https://analyticsdrive.tech/minimum-spanning-tree-prims-algorithm-python-java-cpp/" target="_blank"
      rel="noopener noreferrer" class="share-sidebar__btn share-sidebar__btn--facebook" aria-label="Share on Facebook">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
        <path
          d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.791-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z" />
      </svg>
    </a>

    <!-- Reddit -->
    <a href="https://www.reddit.com/submit?url=https://analyticsdrive.tech/minimum-spanning-tree-prims-algorithm-python-java-cpp/&title=Minimum%20Spanning%20Tree%20with%20Prim%27s%20Algorithm%3A%20Python%2C%20Java%20%26%20C%2B%2B"
      target="_blank" rel="noopener noreferrer" class="share-sidebar__btn share-sidebar__btn--reddit"
      aria-label="Share on Reddit">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
        <path
          d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z" />
      </svg>
    </a>

    <!-- WhatsApp -->
    <a href="https://wa.me/?text=Minimum%20Spanning%20Tree%20with%20Prim%27s%20Algorithm%3A%20Python%2C%20Java%20%26%20C%2B%2B%20https://analyticsdrive.tech/minimum-spanning-tree-prims-algorithm-python-java-cpp/" target="_blank"
      rel="noopener noreferrer" class="share-sidebar__btn share-sidebar__btn--whatsapp" aria-label="Share on WhatsApp">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
        <path
          d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 0 1-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 0 1-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 0 1 2.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0 0 12.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 0 0 5.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 0 0-3.48-8.413z" />
      </svg>
    </a>
  </aside>

  <article class="single-post">
    <header class="post-header">
      <div class="post-meta">
        <time datetime="2026-02-27T12:27:00+00:00">Fri 27 February 2026</time>
      </div>
      <h1>Minimum Spanning Tree with Prim's Algorithm: Python, Java & C++</h1>
    </header>

    <div class="featured-image">
      <img src="https://analyticsdrive.tech/images/minimum-spanning-tree-prims-algorithm-python-java-cpp-hero.webp" alt="Minimum Spanning Tree with Prim's Algorithm: Python, Java & C++" loading="lazy" />
    </div>

    <div class="post-content">
      <p>Navigating the complexities of graph theory is a fundamental skill for any aspiring developer or computer science student. Among the most crucial problems in this domain is finding a Minimum Spanning Tree (MST). This tutorial will thoroughly explore how to implement the <strong>minimum spanning tree using Prim's algorithm in Python, Java, and C++</strong>, equipping you with a robust understanding and practical coding skills. We will delve into the algorithm's mechanics, its practical applications, and provide step-by-step code examples in three popular programming languages, ensuring you can apply this powerful concept across various development environments. Mastering Prim's algorithm is key to efficiently solving a wide range of network optimization problems, making it an invaluable addition to your algorithmic toolkit.</p>
<h2 id="what-is-a-minimum-spanning-tree-mst">What is a Minimum Spanning Tree (MST)?</h2>
<p>Before diving into Prim's algorithm, let's establish a clear understanding of what a Minimum Spanning Tree is. A graph consists of vertices (nodes) and edges (connections between nodes). A <em>spanning tree</em> of an undirected, connected, and weighted graph is a subgraph that connects all the vertices together, without any cycles, and uses the minimum possible number of edges (specifically, V-1 edges for a graph with V vertices).</p>
<p>A <em>Minimum Spanning Tree</em> takes this concept further by adding the element of edge weights. If each edge in the graph has a numerical weight associated with it (e.g., representing distance, cost, or time), an MST is a spanning tree where the sum of the weights of all its edges is minimized. In essence, it's the "cheapest" way to connect all vertices without forming any loops. MSTs are crucial in many real-world scenarios, from designing efficient network layouts to optimizing transportation routes and even in clustering analysis for data science. For related problems focusing on finding shortest paths within a graph, you might explore algorithms like <a href="/dijkstra-algorithm-python-cpp-java-tutorial/">Dijkstra's Algorithm</a> or <a href="/bellman-ford-algorithm-python-cpp-java-tutorial/">Bellman-Ford Algorithm</a>.</p>
<h2 id="understanding-prims-algorithm">Understanding Prim's Algorithm</h2>
<p>Prim's algorithm is a greedy algorithm used to find a Minimum Spanning Tree for a weighted undirected graph. A greedy algorithm makes the locally optimal choice at each stage with the hope of finding a global optimum. Prim's algorithm operates by building the MST one edge at a time, starting from an arbitrary vertex.</p>
<p>The core idea is simple: begin with a single vertex, and then iteratively add the cheapest edge that connects a vertex already in the growing MST to a vertex not yet in the MST. This process continues until all vertices are included in the spanning tree. At each step, Prim's algorithm selects the smallest weight edge that expands the tree without creating a cycle, thereby guaranteeing that the total weight of the chosen edges will be minimized. This makes it an efficient and intuitive method for constructing an MST.</p>
<h3 id="how-prims-algorithm-works-a-step-by-step-breakdown">How Prim's Algorithm Works: A Step-by-Step Breakdown</h3>
<p>To effectively implement Prim's algorithm, it's essential to understand its systematic approach. The algorithm maintains a set of vertices already included in the MST and, at each step, selects an edge that connects a vertex in this set to a vertex outside it, ensuring that the selected edge has the minimum possible weight.</p>
<h3 id="algorithm-steps-for-prims">Algorithm Steps for Prim's</h3>
<p>Here are the detailed steps for Prim's algorithm, which we will follow in our implementations:</p>
<ol>
<li>
<p><strong>Initialize Data Structures:</strong>
    We need a way to keep track of key information. This typically involves:</p>
<ul>
<li><strong><code>key</code> array (or <code>distance</code> array):</strong> Stores the minimum weight of an edge connecting a vertex to the current MST. Initialize <code>key[source_vertex] = 0</code> and <code>key[other_vertices] = infinity</code>.</li>
<li><strong><code>parent</code> array:</strong> Stores the parent of each vertex in the MST. This helps reconstruct the tree. Initialize <code>parent[source_vertex] = -1</code> (or null).</li>
<li><strong><code>inMST</code> array (or <code>visited</code> set):</strong> A boolean array to mark whether a vertex is already included in the MST. Initialize all to <code>false</code>.</li>
<li><strong>Adjacency List:</strong> Represents the graph efficiently, storing neighbors and edge weights for each vertex.</li>
</ul>
</li>
<li>
<p><strong>Choose a Starting Vertex:</strong>
    Select an arbitrary vertex to start building the MST. It doesn't matter which one you pick; the algorithm will find the same MST (assuming the graph is connected). For simplicity, we often choose vertex 0. Set its <code>key</code> to 0.</p>
</li>
<li>
<p><strong>Iterate to Build the MST:</strong>
    Repeat the following V (number of vertices) times:</p>
</li>
<li>
<p><strong>Extract the Minimum Key Vertex:</strong>
    From the set of vertices not yet included in the MST (i.e., <code>inMST[v] == false</code>), select the vertex <code>u</code> that has the minimum <code>key</code> value. This vertex <code>u</code> is the next one to be added to the MST. A priority queue is an ideal data structure for efficiently finding this minimum-key vertex.</p>
</li>
<li>
<p><strong>Add Vertex to MST:</strong>
    Mark <code>u</code> as <code>inMST[u] = true</code>. This signifies that <code>u</code> is now part of our growing Minimum Spanning Tree.</p>
</li>
<li>
<p><strong>Update Neighbors' Key Values:</strong>
    For each neighbor <code>v</code> of <code>u</code> (i.e., for every edge <code>(u, v)</code> with weight <code>w</code>):</p>
<ul>
<li>If <code>v</code> is not yet in the MST (<code>inMST[v] == false</code>) AND the edge weight <code>w</code> is less than the current <code>key[v]</code> value:<ul>
<li>Update <code>key[v] = w</code>.</li>
<li>Set <code>parent[v] = u</code>.</li>
<li>If using a priority queue, update <code>v</code>'s priority or add <code>v</code> with its new key.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Reconstruct the MST:</strong>
    Once the loop finishes, the <code>parent</code> array will contain the structure of the MST. Each <code>(v, parent[v])</code> forms an edge in the MST, except for the starting vertex which has <code>parent</code> as -1. The sum of all <code>key[v]</code> values (excluding the initial 0 for the source) gives the total weight of the MST.</p>
</li>
</ol>
<h3 id="illustrative-example-step-by-step-prims-execution">Illustrative Example: Step-by-Step Prim's Execution</h3>
<p>Let's walk through a simple example to solidify your understanding. Consider a graph with 4 vertices (A, B, C, D) and the following edges:
*   (A, B) weight 1
*   (A, C) weight 3
*   (B, C) weight 1
*   (B, D) weight 5
*   (C, D) weight 2</p>
<p>We'll use vertex A as our starting point.</p>
<p><strong>Initial State:</strong>
*   <code>key</code>: [A:0, B:âˆž, C:âˆž, D:âˆž]
*   <code>parent</code>: [A:-1, B:-1, C:-1, D:-1]
*   <code>inMST</code>: [A:F, B:F, C:F, D:F]
*   <code>PriorityQueue</code>: [(0, A, None)]</p>
<p><strong>Iteration 1:</strong>
1.  Extract (0, A, None) from PQ. <code>A</code> is not in MST.
2.  Mark <code>inMST[A] = True</code>. Total cost: 0. Add A to MST.
3.  Neighbors of A:
    *   B (weight 1): <code>inMST[B]</code> is False, 1 &lt; <code>key[B]</code> (âˆž). Update <code>key[B]=1</code>, <code>parent[B]=A</code>. Add (1, B, A) to PQ.
    *   C (weight 3): <code>inMST[C]</code> is False, 3 &lt; <code>key[C]</code> (âˆž). Update <code>key[C]=3</code>, <code>parent[C]=A</code>. Add (3, C, A) to PQ.
    <code>PriorityQueue</code>: [(1, B, A), (3, C, A)]</p>
<p><strong>Iteration 2:</strong>
1.  Extract (1, B, A) from PQ. <code>B</code> is not in MST.
2.  Mark <code>inMST[B] = True</code>. Total cost: 0 + 1 = 1. Add edge (A, B, 1) to MST.
3.  Neighbors of B:
    *   A (weight 1): <code>inMST[A]</code> is True. Skip.
    *   C (weight 1): <code>inMST[C]</code> is False, 1 &lt; <code>key[C]</code> (3). Update <code>key[C]=1</code>, <code>parent[C]=B</code>. Add (1, C, B) to PQ. (Note: A new, better path to C found!)
    *   D (weight 5): <code>inMST[D]</code> is False, 5 &lt; <code>key[D]</code> (âˆž). Update <code>key[D]=5</code>, <code>parent[D]=B</code>. Add (5, D, B) to PQ.
    <code>PriorityQueue</code>: [(1, C, B), (3, C, A), (5, D, B)] (PQ will sort by weight, so (1, C, B) is next)</p>
<p><strong>Iteration 3:</strong>
1.  Extract (1, C, B) from PQ. <code>C</code> is not in MST.
2.  Mark <code>inMST[C] = True</code>. Total cost: 1 + 1 = 2. Add edge (B, C, 1) to MST.
3.  Neighbors of C:
    *   A (weight 3): <code>inMST[A]</code> is True. Skip.
    *   B (weight 1): <code>inMST[B]</code> is True. Skip.
    *   D (weight 2): <code>inMST[D]</code> is False, 2 &lt; <code>key[D]</code> (5). Update <code>key[D]=2</code>, <code>parent[D]=C</code>. Add (2, D, C) to PQ.
    <code>PriorityQueue</code>: [(2, D, C), (3, C, A), (5, D, B)] (The older (3, C, A) and (5, D, B) are now redundant but will be skipped when extracted)</p>
<p><strong>Iteration 4:</strong>
1.  Extract (2, D, C) from PQ. <code>D</code> is not in MST.
2.  Mark <code>inMST[D] = True</code>. Total cost: 2 + 2 = 4. Add edge (C, D, 2) to MST.
3.  Neighbors of D:
    *   B (weight 5): <code>inMST[B]</code> is True. Skip.
    *   C (weight 2): <code>inMST[C]</code> is True. Skip.
    All vertices are now in MST.</p>
<p><strong>Final MST:</strong>
Edges: (A, B, 1), (B, C, 1), (C, D, 2)
Total Weight: 4</p>
<p>This detailed walkthrough helps to illustrate how Prim's algorithm systematically builds the MST by always picking the locally cheapest, valid edge.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>To get the most out of this tutorial and successfully implement Prim's algorithm, you should have:</p>
<ul>
<li><strong>Basic Understanding of Graph Theory:</strong> Familiarity with concepts like vertices, edges, weights, connected graphs, and cycles. For examples of other graph traversal problems, consider learning about the <a href="/cses-labyrinth-problem-python-java-cpp-guide/">CSES Labyrinth Problem</a>.</li>
<li><strong>Data Structure Knowledge:</strong> A good grasp of adjacency lists (or matrices), arrays, and especially priority queues (min-heaps).</li>
<li><strong>Programming Fundamentals:</strong> Basic to intermediate programming skills in at least one of Python, Java, or C++, including loops, conditional statements, and custom classes/structs.</li>
<li><strong>Object-Oriented Programming (for Java/C++):</strong> Understanding how to define and use classes and objects will be beneficial for representing graph edges or nodes.</li>
</ul>
<h2 id="implementing-minimum-spanning-tree-using-prims-algorithm-in-python-java-and-c">Implementing Minimum Spanning Tree using Prim's Algorithm in Python, Java, and C++</h2>
<p>Let's dive into the practical implementation of Prim's algorithm in our chosen languages. We will use an adjacency list to represent the graph and a priority queue to efficiently select the next minimum-weight edge.</p>
<h3 id="implementation-in-python">Implementation in Python</h3>
<p>Python's <code>heapq</code> module provides a min-heap implementation, which is perfect for our priority queue needs. We'll represent the graph using an adjacency list where each entry stores tuples of <code>(weight, neighbor)</code>.</p>
<h4 id="1-representing-the-graph">1. Representing the Graph</h4>
<p>We'll use a dictionary of lists for the adjacency list. <code>graph[u]</code> will contain <code>(weight, v)</code> for all neighbors <code>v</code> of <code>u</code>.</p>
<h4 id="2-initializing-data-structures">2. Initializing Data Structures</h4>
<p>We'll need <code>min_heap</code> (priority queue), <code>visited</code> set, <code>min_cost_so_far</code> for total MST weight, and a list to store MST edges.</p>
<h4 id="3-prims-algorithm-function">3. Prim's Algorithm Function</h4>
<p>The main function will initialize the heap with a starting vertex and then iteratively extract the minimum edge.</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">def</span> <span class="nf">prim_mst_python</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the Minimum Spanning Tree (MST) of a weighted undirected graph</span>
<span class="sd">    using Prim&#39;s algorithm.</span>

<span class="sd">    Args:</span>
<span class="sd">        graph (dict): A dictionary representing the adjacency list of the graph.</span>
<span class="sd">                      Each key is a vertex, and its value is a list of tuples</span>
<span class="sd">                      (weight, neighbor). Example: {0: [(1, 1), (2, 4)], ...}</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - float: The total minimum cost of the MST.</span>
<span class="sd">            - list: A list of tuples (u, v, weight) representing the edges in the MST.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]</span>

    <span class="c1"># Choose an arbitrary starting vertex (e.g., the first one in the graph keys)</span>
    <span class="n">start_node</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span> 

    <span class="c1"># Priority queue stores tuples: (weight, current_vertex, parent_vertex)</span>
    <span class="c1"># The parent_vertex is None for the start_node itself.</span>
    <span class="n">min_heap</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> 

    <span class="c1"># Set to keep track of visited nodes (nodes included in the MST)</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># List to store the edges of the MST</span>
    <span class="n">mst_edges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Total cost of the MST</span>
    <span class="n">min_cost</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">min_heap</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
        <span class="c1"># Extract the edge with the minimum weight</span>
        <span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span>

        <span class="c1"># If the vertex is already visited, skip it (this handles duplicate entries in heap)</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Mark the current vertex as visited (add it to the MST)</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">min_cost</span> <span class="o">+=</span> <span class="n">weight</span>

        <span class="c1"># Add the edge to our MST if it&#39;s not the starting node&#39;s initial entry</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mst_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>

        <span class="c1"># Explore neighbors of the newly added vertex &#39;u&#39;</span>
        <span class="k">for</span> <span class="n">edge_weight</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="c1"># Add neighbor to the priority queue. The current vertex &#39;u&#39; is its parent.</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="p">(</span><span class="n">edge_weight</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>

    <span class="c1"># Check if all vertices were included (graph might be disconnected)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
        <span class="c1"># If not all vertices are visited, the graph is disconnected,</span>
        <span class="c1"># and a single MST cannot be formed.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: Graph is disconnected. MST found for connected component only.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">min_cost</span><span class="p">,</span> <span class="n">mst_edges</span>

<span class="c1">#### 4. Example Usage in Python</span>

<span class="err">```</span><span class="n">python</span>
<span class="c1"># Example graph representation (adjacency list)</span>
<span class="c1"># {vertex: [(weight, neighbor), ...]}</span>
<span class="n">graph_python_simple</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">)],</span>
    <span class="mi">1</span><span class="p">:</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">7</span><span class="p">)],</span>
    <span class="mi">2</span><span class="p">:</span> <span class="p">[(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">)],</span>
    <span class="mi">3</span><span class="p">:</span> <span class="p">[(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span>
    <span class="mi">4</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span>
    <span class="mi">5</span><span class="p">:</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)],</span>
    <span class="mi">6</span><span class="p">:</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span>
    <span class="mi">7</span><span class="p">:</span> <span class="p">[(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)],</span>
    <span class="mi">8</span><span class="p">:</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>
<span class="p">}</span>


<span class="n">cost_py</span><span class="p">,</span> <span class="n">mst_py</span> <span class="o">=</span> <span class="n">prim_mst_python</span><span class="p">(</span><span class="n">graph_python_simple</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Python MST Cost: </span><span class="si">{</span><span class="n">cost_py</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Python MST Edges:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">mst_py</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  (</span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">) - Weight: </span><span class="si">{</span><span class="n">w</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="implementation-in-java">Implementation in Java</h3>
<p>In Java, we'll create a custom <code>Edge</code> class to store target vertex and weight. The graph will be an <code>ArrayList</code> of <code>ArrayList&lt;Edge&gt;</code>. Java's <code>PriorityQueue</code> will be used for the min-heap.</p>
<h4 id="1-representing-the-graph_1">1. Representing the Graph</h4>
<p>We'll define an <code>Edge</code> class to make graph representation clear. The graph itself will be an <code>ArrayList</code> of <code>ArrayList&lt;Edge&gt;</code>.</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.*</span><span class="p">;</span>

<span class="c1">// Helper class to represent an edge in the graph</span>
<span class="kd">class</span> <span class="nc">Edge</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">source</span><span class="p">;</span><span class="w"> </span><span class="c1">// Added source for easier MST edge reconstruction</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Edge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">compareTo</span><span class="p">(</span><span class="n">Edge</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">compare</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">weight</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="na">weight</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">PrimMSTJava</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Finds the Minimum Spanning Tree (MST) of a weighted undirected graph</span>
<span class="cm">     * using Prim&#39;s algorithm.</span>
<span class="cm">     *</span>
<span class="cm">     * @param numVertices The total number of vertices in the graph.</span>
<span class="cm">     * @param adj         An adjacency list where adj[i] contains a list of Edge objects</span>
<span class="cm">     *                    representing connections from vertex i.</span>
<span class="cm">     * @return A list of Edge objects forming the MST, or an empty list if no MST.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">primMST</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">numVertices</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">adj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">numVertices</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Stores the minimum cost to reach a vertex from the MST</span>
<span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">numVertices</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// Stores the parent of each vertex in the MST</span>
<span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">numVertices</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// Tracks if a vertex is already included in the MST</span>
<span class="w">        </span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">inMST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[</span><span class="n">numVertices</span><span class="o">]</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Initialize key values to infinity, parent to -1, and inMST to false</span>
<span class="w">        </span><span class="n">Arrays</span><span class="p">.</span><span class="na">fill</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">);</span>
<span class="w">        </span><span class="n">Arrays</span><span class="p">.</span><span class="na">fill</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Priority queue to store edges, ordered by weight</span>
<span class="w">        </span><span class="c1">// Stores Edge objects: (source, target, weight)</span>
<span class="w">        </span><span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PriorityQueue</span><span class="o">&lt;&gt;</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// Start from vertex 0 (arbitrary choice)</span>
<span class="w">        </span><span class="n">key</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Cost to reach starting node is 0</span>
<span class="w">        </span><span class="n">pq</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Edge</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"> </span><span class="c1">// Dummy edge to start, source -1 indicates no parent</span>

<span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mstEdges</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">edgesCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// To track if we&#39;ve added V-1 edges</span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">edgesCount</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVertices</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Extract the edge with the minimum weight</span>
<span class="w">            </span><span class="n">Edge</span><span class="w"> </span><span class="n">currentEdge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pq</span><span class="p">.</span><span class="na">poll</span><span class="p">();</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentEdge</span><span class="p">.</span><span class="na">target</span><span class="p">;</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentEdge</span><span class="p">.</span><span class="na">weight</span><span class="p">;</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">currentParent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentEdge</span><span class="p">.</span><span class="na">source</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// If the vertex is already in MST, skip it (can have multiple entries for same vertex)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inMST</span><span class="o">[</span><span class="n">u</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">continue</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// Add vertex u to MST</span>
<span class="w">            </span><span class="n">inMST</span><span class="o">[</span><span class="n">u</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// If it&#39;s not the dummy start edge, add it to the MST edges list</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">currentParent</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">mstEdges</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Edge</span><span class="p">(</span><span class="n">currentParent</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="p">));</span>
<span class="w">                </span><span class="n">edgesCount</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// Explore neighbors of u</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Edge</span><span class="w"> </span><span class="n">neighborEdge</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">adj</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">neighborEdge</span><span class="p">.</span><span class="na">target</span><span class="p">;</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">edgeWeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">neighborEdge</span><span class="p">.</span><span class="na">weight</span><span class="p">;</span>

<span class="w">                </span><span class="c1">// If v is not in MST and current edge (u,v) is lighter than previous best for v</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">inMST</span><span class="o">[</span><span class="n">v</span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">edgeWeight</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">key</span><span class="o">[</span><span class="n">v</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">key</span><span class="o">[</span><span class="n">v</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edgeWeight</span><span class="p">;</span>
<span class="w">                    </span><span class="n">parent</span><span class="o">[</span><span class="n">v</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"> </span><span class="c1">// Set u as parent of v</span>
<span class="w">                    </span><span class="n">pq</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">edgeWeight</span><span class="p">));</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// After building, verify if MST is complete (graph connected)</span>
<span class="w">        </span><span class="c1">// If the graph is disconnected, mstEdges will contain a spanning forest for a component.</span>
<span class="w">        </span><span class="c1">// A full MST requires edgesCount == numVertices - 1 for a connected graph.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">edgesCount</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">numVertices</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">numVertices</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Warning: Graph might be disconnected. MST found for a connected component only.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">mstEdges</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Helper to build adjacency list for undirected graph</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="nf">buildAdjList</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">numVertices</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">edges</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVertices</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">adj</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">());</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">edges</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edge</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="n">adj</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">u</span><span class="p">).</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">));</span>
<span class="w">            </span><span class="n">adj</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">v</span><span class="p">).</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">));</span><span class="w"> </span><span class="c1">// For undirected graph</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h4 id="2-example-usage-in-java">2. Example Usage in Java</h4>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numVertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// Edges: {u, v, weight}</span>
<span class="w">        </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">edges_java</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">}</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buildAdjList</span><span class="p">(</span><span class="n">numVertices</span><span class="p">,</span><span class="w"> </span><span class="n">edges_java</span><span class="p">);</span>

<span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mstJava</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">primMST</span><span class="p">(</span><span class="n">numVertices</span><span class="p">,</span><span class="w"> </span><span class="n">adj</span><span class="p">);</span>

<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">totalCostJava</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Java MST Edges:&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Edge</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">mstJava</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;  (&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">edge</span><span class="p">.</span><span class="na">source</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">edge</span><span class="p">.</span><span class="na">target</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;) - Weight: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">edge</span><span class="p">.</span><span class="na">weight</span><span class="p">);</span>
<span class="w">            </span><span class="n">totalCostJava</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">edge</span><span class="p">.</span><span class="na">weight</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Java MST Cost: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">totalCostJava</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="implementation-in-c">Implementation in C++</h3>
<p>C++ offers <code>std::vector</code> for adjacency lists and <code>std::priority_queue</code> for the min-heap. <code>std::pair</code> can represent edges. Note that <code>std::priority_queue</code> is a max-heap by default, so we'll need to use <code>std::greater</code> or negate weights to simulate a min-heap.</p>
<h4 id="1-representing-the-graph_2">1. Representing the Graph</h4>
<p>We'll use <code>std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt;</code> where <code>pair&lt;int, int&gt;</code> stores <code>{neighbor, weight}</code>.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;queue&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;limits&gt;</span><span class="c1"> // For numeric_limits</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tuple&gt;</span><span class="c1">  // For std::tuple</span>

<span class="c1">// Helper struct to represent an edge for the priority queue</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Edge</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">target_node</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">source_node</span><span class="p">;</span><span class="w"> </span><span class="c1">// Added source for easier MST edge reconstruction</span>

<span class="w">    </span><span class="c1">// Custom comparator for priority_queue to make it a min-heap</span>
<span class="w">    </span><span class="c1">// Priority queue stores elements in descending order by default.</span>
<span class="w">    </span><span class="c1">// To get a min-heap, we either store negative weights or use std::greater.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Edge</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Function to find the Minimum Spanning Tree using Prim&#39;s algorithm</span>
<span class="c1">// Returns a pair: {total_mst_weight, list_of_mst_edges}</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">primMST_cpp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">numVertices</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;&gt;&amp;</span><span class="w"> </span><span class="n">adj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">numVertices</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">{}};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Min-priority queue: stores {weight, target_node, source_node}</span>
<span class="w">    </span><span class="c1">// Using std::greater&lt;Edge&gt; makes it a min-heap based on &#39;weight&#39;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">pq</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Stores the minimum cost to reach a vertex from the MST</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">key</span><span class="p">(</span><span class="n">numVertices</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
<span class="w">    </span><span class="c1">// Tracks if a vertex is already included in the MST</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inMST</span><span class="p">(</span><span class="n">numVertices</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Stores the parent of each vertex in the MST</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parent</span><span class="p">(</span><span class="n">numVertices</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Start from vertex 0 (arbitrary choice)</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">startNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">key</span><span class="p">[</span><span class="n">startNode</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">startNode</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">});</span><span class="w"> </span><span class="c1">// {weight, target, source} dummy edge to start</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">mstEdges</span><span class="p">;</span><span class="w"> </span><span class="c1">// Stores {source, target, weight}</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">totalMSTWeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">edgesCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">edgesCount</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numVertices</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Edge</span><span class="w"> </span><span class="n">currentEdge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
<span class="w">        </span><span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentEdge</span><span class="p">.</span><span class="n">target_node</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">weight_u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentEdge</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">parent_u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentEdge</span><span class="p">.</span><span class="n">source_node</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If &#39;u&#39; is already in MST, skip (can have multiple entries for same vertex in PQ)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inMST</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Add vertex &#39;u&#39; to MST</span>
<span class="w">        </span><span class="n">inMST</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="n">totalMSTWeight</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">weight_u</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If it&#39;s not the dummy start edge, add it to the MST edges list</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parent_u</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">mstEdges</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">parent_u</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">weight_u</span><span class="p">);</span>
<span class="w">            </span><span class="n">edgesCount</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Explore neighbors of &#39;u&#39;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">neighbor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">neighbor</span><span class="p">.</span><span class="n">first</span><span class="p">;</span><span class="w">    </span><span class="c1">// Neighbor vertex</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">edgeWeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">neighbor</span><span class="p">.</span><span class="n">second</span><span class="p">;</span><span class="w"> </span><span class="c1">// Weight of edge (u,v)</span>

<span class="w">            </span><span class="c1">// If &#39;v&#39; is not in MST and current edge (u,v) is lighter than previous best for &#39;v&#39;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">inMST</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">edgeWeight</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edgeWeight</span><span class="p">;</span>
<span class="w">                </span><span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"> </span><span class="c1">// Set u as parent of v</span>
<span class="w">                </span><span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">edgeWeight</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">});</span><span class="w"> </span><span class="c1">// Add this potential edge to PQ</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Check if all vertices were included (graph might be disconnected)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">edgesCount</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">numVertices</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">numVertices</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Warning: Graph might be disconnected. MST found for a connected component only.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">totalMSTWeight</span><span class="p">,</span><span class="w"> </span><span class="n">mstEdges</span><span class="p">};</span>
<span class="p">}</span>

<span class="c1">// Helper to build adjacency list for undirected graph</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">buildAdjList_cpp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">numVertices</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">edges</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">adj</span><span class="p">(</span><span class="n">numVertices</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">edges</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
<span class="w">        </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">});</span>
<span class="w">        </span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">});</span><span class="w"> </span><span class="c1">// For undirected graph</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#### 2. Example Usage in C++</span>

<span class="err">```</span><span class="n">cpp</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">numVertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Edges: {u, v, weight}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">edges_cpp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buildAdjList_cpp</span><span class="p">(</span><span class="n">numVertices</span><span class="p">,</span><span class="w"> </span><span class="n">edges_cpp</span><span class="p">);</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">primMST_cpp</span><span class="p">(</span><span class="n">numVertices</span><span class="p">,</span><span class="w"> </span><span class="n">adj</span><span class="p">);</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">totalCostCpp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">mstCpp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;C++ MST Cost: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">totalCostCpp</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;C++ MST Edges:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">mstCpp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;) - Weight: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="time-and-space-complexity-analysis">Time and Space Complexity Analysis</h2>
<p>Understanding the performance characteristics of Prim's algorithm is crucial for choosing the right algorithm for a given problem.</p>
<h3 id="time-complexity">Time Complexity</h3>
<p>The time complexity of Prim's algorithm largely depends on how the priority queue is implemented. This choice is critical for performance, especially with large graphs.</p>
<ul>
<li>
<p><strong>With an adjacency list and a binary heap (as implemented above):</strong> This is the most common and efficient implementation for general graphs.</p>
<ul>
<li><strong>Initialization:</strong> Setting up the <code>key</code>, <code>parent</code>, and <code>inMST</code> arrays takes <strong>O(V)</strong> time, where V is the number of vertices.</li>
<li><strong>Main Loop:</strong> The <code>while</code> loop runs up to V times, as each vertex is added to the MST exactly once.</li>
<li><strong>Inside the loop:</strong><ul>
<li><code>pq.pop()</code> (extract-min operation): In a binary heap, this takes <strong>O(log N)</strong> time, where N is the current number of elements in the priority queue. In the worst case, the PQ can hold up to <code>E</code> edges or <code>V</code> vertices, so it's often approximated as O(log E) or O(log V).</li>
<li><strong>Neighbor exploration:</strong> For each vertex <code>u</code> added to the MST, we iterate through its adjacent edges. In total, across all V iterations, every edge in the graph <code>(u, v)</code> is processed twice (once when <code>u</code> is processed, and once when <code>v</code> is processed).</li>
<li><code>pq.push()</code> (insert operation): Adding a potential edge to the priority queue also takes <strong>O(log N)</strong> time.</li>
</ul>
</li>
<li><strong>Overall:</strong> Since there are <code>V</code> extractions and up to <code>E</code> insertions (each taking <code>log E</code> time), the total time complexity is <strong>O(E log V)</strong>. This efficiency makes it suitable for sparse graphs (where E is much smaller than V^2). For dense graphs, where E approaches V^2, this complexity approaches O(V^2 log V), which can be less efficient than the simple array scan method.</li>
</ul>
</li>
<li>
<p><strong>With an adjacency matrix and a simple array scan to find the minimum key:</strong> This approach is simpler to implement but less efficient for many graph types.</p>
<ul>
<li>The algorithm iterates V times. In each iteration, it scans all V vertices to find the one with the minimum <code>key</code> value that is not yet in the MST. This scan takes O(V) time.</li>
<li>After adding a vertex, it then updates the <code>key</code> values for its neighbors, which can take another O(V) time (checking all possible edges in an adjacency matrix row/column).</li>
<li>Total time: <strong>O(V^2)</strong>. This is often preferred for very dense graphs where E is close to V^2, as O(V^2) can be faster than O(V^2 log V).</li>
</ul>
</li>
<li>
<p><strong>With an adjacency list and a Fibonacci heap (more complex, theoretical):</strong></p>
<ul>
<li>While theoretically achieving <strong>O(E + V log V)</strong>, Fibonacci heaps are complex to implement and have high constant factors, making them less practical for competitive programming or typical production environments compared to binary heaps.</li>
</ul>
</li>
</ul>
<p>For graph problems where all-pairs shortest paths are needed, the <a href="/floyd-warshall-algorithm-python-java-cpp/">Floyd-Warshall Algorithm</a> offers a different approach for dense graphs.</p>
<h3 id="space-complexity">Space Complexity</h3>
<p>The space complexity for Prim's algorithm using an adjacency list and a binary heap is as follows:</p>
<ul>
<li><strong>Adjacency List:</strong> O(V + E) to store the graph structure itself, where V is the number of vertices and E is the number of edges. This is because each vertex and each edge (twice for undirected graphs) is stored.</li>
<li><strong><code>key</code> array:</strong> O(V) to store the minimum edge weight to each vertex.</li>
<li><strong><code>parent</code> array:</strong> O(V) to reconstruct the MST paths.</li>
<li><strong><code>inMST</code> (or <code>visited</code>) array/set:</strong> O(V) to keep track of visited vertices.</li>
<li><strong>Priority Queue:</strong> In the worst case, the priority queue might store up to E edges (if all edges connecting to the growing MST are added before being processed). In some optimized implementations, it only stores vertices, and its size is O(V). Therefore, it's generally <strong>O(E)</strong> or <strong>O(V)</strong>, depending on the exact implementation details.</li>
<li><strong>MST Edges List:</strong> O(V) to store the V-1 edges of the resulting Minimum Spanning Tree.</li>
</ul>
<p>Combining these, the total space complexity is <strong>O(V + E)</strong>. This makes it efficient in terms of memory usage, especially for sparse graphs where E is not excessively large.</p>
<h2 id="common-mistakes-and-how-to-avoid-them">Common Mistakes and How to Avoid Them</h2>
<p>Implementing graph algorithms like Prim's can be tricky. Here are some common pitfalls and advice on how to avoid them:</p>
<h3 id="1-incorrect-priority-queue-management">1. Incorrect Priority Queue Management</h3>
<ul>
<li><strong>Mistake:</strong> Using a max-heap instead of a min-heap, leading to a Maximum Spanning Tree (which is usually not what's desired).</li>
<li><strong>Avoidance:</strong> Always ensure your priority queue extracts the <em>minimum</em> weight element. In C++, use <code>std::priority_queue&lt;Edge, std::vector&lt;Edge&gt;, std::greater&lt;Edge&gt;&gt;</code>. In Python, <code>heapq</code> is a min-heap by default. In Java, ensure your <code>Comparable</code> implementation or <code>Comparator</code> sorts in ascending order by weight.</li>
<li><strong>Mistake:</strong> Not correctly updating a vertex's key in the priority queue. If a vertex <code>v</code> is already in the priority queue with a certain key, and a new, cheaper edge to <code>v</code> is discovered, simply adding <code>v</code> again can lead to redundant processing or even incorrect results if the algorithm processes an outdated, more expensive path.</li>
<li><strong>Avoidance:</strong> The most common and simple way to handle this with a binary heap is to just add the new (better) entry to the priority queue. When extracting from the PQ, always perform a <code>visited</code> check. If the vertex has already been <code>visited</code>, simply skip it and continue to the next extraction. This implicitly ensures you always process the cheapest valid path to a vertex first.</li>
</ul>
<h3 id="2-forgetting-to-mark-visited-nodes">2. Forgetting to Mark Visited Nodes</h3>
<ul>
<li><strong>Mistake:</strong> Not marking vertices as <code>inMST</code> (<code>visited</code>) once they are added to the MST. This can lead to the algorithm re-processing edges to already included vertices, potentially forming cycles in the MST or resulting in an incorrect total weight due to redundant path consideration.</li>
<li><strong>Avoidance:</strong> As soon as a vertex <code>u</code> is extracted from the priority queue and determined to be valid (i.e., <code>inMST[u]</code> is false), mark <code>inMST[u] = true</code> <em>before</em> you iterate through its neighbors. This ensures that any subsequent attempts to add <code>u</code> or use <code>u</code> as a destination from an existing MST node are correctly filtered.</li>
</ul>
<h3 id="3-incorrectly-updating-neighbor-weights">3. Incorrectly Updating Neighbor Weights</h3>
<ul>
<li><strong>Mistake:</strong> Updating <code>key[v]</code> for a neighbor <code>v</code> only if <code>v</code> is <em>not</em> in the MST, but not also checking if the new edge weight is <em>smaller</em> than the current <code>key[v]</code>. If <code>key[v]</code> already holds a cheaper path, updating it with a more expensive one is a critical error.</li>
<li><strong>Avoidance:</strong> The condition <code>!inMST[v] &amp;&amp; edgeWeight &lt; key[v]</code> is crucial. You only want to update <code>key[v]</code> and add to the priority queue if the newly discovered edge from <code>u</code> to <code>v</code> offers a <em>better</em> (cheaper) way to connect <code>v</code> to the growing MST than any path found previously.</li>
</ul>
<h3 id="4-handling-disconnected-graphs">4. Handling Disconnected Graphs</h3>
<ul>
<li><strong>Mistake:</strong> Assuming Prim's will always produce a single spanning tree for any given graph.</li>
<li><strong>Avoidance:</strong> Prim's algorithm intrinsically works on connected components. If a graph is disconnected, running Prim's from one starting vertex will only find the MST of the connected component containing that vertex. To determine if the graph was fully connected, you can check if <code>len(visited) == len(graph)</code> (in Python) or <code>edgesCount == numVertices - 1</code> (in Java/C++) after the main loop finishes. If not, the result is an MST of a component, or a "minimum spanning forest" if you apply it iteratively to all components.</li>
</ul>
<h3 id="5-off-by-one-errors-in-graph-representation">5. Off-by-One Errors in Graph Representation</h3>
<ul>
<li><strong>Mistake:</strong> Incorrectly handling 0-indexed vs. 1-indexed vertices, which can lead to <code>IndexOutOfBounds</code> errors or incorrect graph traversals.</li>
<li><strong>Avoidance:</strong> Be consistent with your vertex indexing throughout the problem. If your problem statement or dataset uses 1-indexed nodes, map them to 0-indexed internally for array/list access, or adjust array sizes accordingly to accommodate 1-based indexing.</li>
</ul>
<h3 id="6-edge-case-graph-with-one-vertex">6. Edge Case: Graph with One Vertex</h3>
<ul>
<li><strong>Mistake:</strong> Not explicitly considering a graph with a single vertex or an empty graph.</li>
<li><strong>Avoidance:</strong> A single-vertex graph has an MST with 0 cost and 0 edges, as it's already "connected." An empty graph also has 0 cost and 0 edges. Your code should handle these edge cases gracefully, usually by checking <code>numVertices == 0</code> or <code>numVertices == 1</code> at the beginning of your Prim's function.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>You've now taken a significant step in mastering graph algorithms by delving into the <strong>minimum spanning tree using Prim's algorithm in Python, Java, and C++</strong>. We've covered the fundamental concepts of MSTs, the greedy approach behind Prim's algorithm, and provided detailed, step-by-step implementations across three major programming languages. Understanding Prim's algorithm is not just about writing code; it's about grasping an elegant solution to a pervasive problem in computer science and engineering.</p>
<p>Prim's algorithm stands out for its efficiency, particularly with a priority queue, making it a go-to choice for scenarios like network design, circuit layout, and cluster analysis where finding the cheapest way to connect components is paramount. By internalizing its logic and practicing these implementations, you're well on your way to tackling more complex graph problems and building robust, optimized solutions. Keep practicing, experiment with different graph structures, and you'll find Prim's to be an invaluable tool in your algorithmic arsenal.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<p><strong>Q: What is the primary difference between Prim's and Kruskal's algorithm for finding an MST?</strong>
A: Both Prim's and Kruskal's are greedy algorithms for finding an MST. Prim's algorithm starts from a single vertex and grows the MST by adding the cheapest edge connected to a vertex already in the MST. Kruskal's algorithm, on the other hand, considers all edges in increasing order of weight and adds an edge if it doesn't form a cycle with previously added edges, effectively building a "spanning forest" that eventually merges into a single MST.</p>
<p><strong>Q: When should I choose Prim's algorithm over other MST algorithms?</strong>
A: Prim's algorithm is generally preferred for dense graphs (graphs with many edges relative to the number of vertices) when implemented with a binary heap, as its O(E log V) complexity can become O(V^2 log V) in dense cases, which is comparable to its O(V^2) adjacency matrix implementation. It's particularly efficient when you need to start building the MST from a specific source vertex, although the starting vertex doesn't affect the final MST.</p>
<p><strong>Q: Can Prim's algorithm be used on disconnected graphs?</strong>
A: No, Prim's algorithm, by itself, is designed for connected graphs. If you run Prim's on a disconnected graph, it will find the Minimum Spanning Tree for the connected component that contains the arbitrary starting vertex. To find a Minimum Spanning Forest (a set of MSTs, one for each connected component) for a disconnected graph, you would need to run Prim's multiple times, starting from an unvisited vertex each time until all components are covered.</p>
<h2 id="further-reading-resources">Further Reading &amp; Resources</h2>
<ul>
<li><strong>Wikipedia:</strong> <a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim's algorithm</a></li>
<li><strong>GeeksforGeeks:</strong> <a href="https://www.geeksforgeeks.org/prims-mst-for-adjacency-list-representation-greedy-algo-5/">Prim's Algorithm for Minimum Spanning Tree (MST)</a></li>
<li><strong>MIT OpenCourseware:</strong> <a href="https://ocw.mit.edu/courses/6-046j-design-and-analysis-of-algorithms-spring-2015/resources/lecture-15-minimum-spanning-trees-prims-and-kruskals/">Algorithms, Lecture 15: Minimum Spanning Trees, Prim's and Kruskal's</a></li>
<li><strong>TopCoder Tutorials:</strong> <a href="https://www.topcoder.com/thrive/articles/Minimum%20Spanning%20Tree%20-%20Prim%27s%20Algorithm">Minimum Spanning Tree - Prim's Algorithm</a></li>
</ul>
    </div>

    <!-- Social Share Buttons -->
    <div class="share-buttons">
      <span class="share-label">Share:</span>

      <!-- X (Twitter) -->
      <a href="https://twitter.com/intent/tweet?url=https://analyticsdrive.tech/minimum-spanning-tree-prims-algorithm-python-java-cpp/&text=Minimum%20Spanning%20Tree%20with%20Prim%27s%20Algorithm%3A%20Python%2C%20Java%20%26%20C%2B%2B"
        target="_blank" rel="noopener noreferrer" class="share-btn share-btn--twitter" aria-label="Share on X">
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
        </svg>
      </a>

      <!-- Facebook -->
      <a href="https://www.facebook.com/sharer/sharer.php?u=https://analyticsdrive.tech/minimum-spanning-tree-prims-algorithm-python-java-cpp/" target="_blank"
        rel="noopener noreferrer" class="share-btn share-btn--facebook" aria-label="Share on Facebook">
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.791-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z" />
        </svg>
      </a>

      <!-- Reddit -->
      <a href="https://www.reddit.com/submit?url=https://analyticsdrive.tech/minimum-spanning-tree-prims-algorithm-python-java-cpp/&title=Minimum%20Spanning%20Tree%20with%20Prim%27s%20Algorithm%3A%20Python%2C%20Java%20%26%20C%2B%2B"
        target="_blank" rel="noopener noreferrer" class="share-btn share-btn--reddit" aria-label="Share on Reddit">
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z" />
        </svg>
      </a>

      <!-- WhatsApp -->
      <a href="https://wa.me/?text=Minimum%20Spanning%20Tree%20with%20Prim%27s%20Algorithm%3A%20Python%2C%20Java%20%26%20C%2B%2B%20https://analyticsdrive.tech/minimum-spanning-tree-prims-algorithm-python-java-cpp/" target="_blank"
        rel="noopener noreferrer" class="share-btn share-btn--whatsapp" aria-label="Share on WhatsApp">
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 0 1-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 0 1-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 0 1 2.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0 0 12.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 0 0 5.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 0 0-3.48-8.413z" />
        </svg>
      </a>
    </div>

    <div class="article-footer-meta">
      <p><strong>Category:</strong> <a href="https://analyticsdrive.tech/category/data-structures-algorithms.html">Data Structures & Algorithms</a></p>
      <div class="tags-list">
        <strong>Tags:</strong>
        <span class="tag">#prim's algorithm</span>
        <span class="tag">#minimum spanning tree</span>
        <span class="tag">#graph theory</span>
        <span class="tag">#python</span>
        <span class="tag">#java</span>
        <span class="tag">#c++</span>
        <span class="tag">#data structures</span>
        <span class="tag">#algorithms</span>
        <span class="tag">#coding tutorial</span>
        <span class="tag">#greedy algorithm</span>
      </div>
    </div>

    <div class="related-posts">
      <h3>Related Articles</h3>
      <ul>
        <li><a href="https://analyticsdrive.tech/floyd-warshall-algorithm-python-java-cpp/">Floyd Warshall Algorithm in Python, Java & C++: A Tutorial</a></li>
        <li><a href="https://analyticsdrive.tech/segment-tree-tutorial-python-java-cpp/">Segment Tree in Python, Java & C++: A Comprehensive Guide</a></li>
        <li><a href="https://analyticsdrive.tech/dijkstra-algorithm-python-cpp-java-tutorial/">Dijkstra Algorithm in Python, C++, Java: A Comprehensive Guide</a></li>
      </ul>
    </div>

    <div class="post-footer">
      <a href="https://analyticsdrive.tech/" class="back-link">&larr; Back to Home</a>
    </div>
  </article>

</div>    </main>

    <footer class="site-footer">
        <div class="container">
            <p>&copy; 2026 Analytics Drive.
            </p>
            <div class="social-links">
                <a href="https://twitter.com/analyticsdrive" target="_blank" aria-label="Twitter">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="currentColor">
                        <path
                            d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
                    </svg>
                </a>
                <a href="https://www.facebook.com/profile.php?id=61588072082428" target="_blank" aria-label="Facebook">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="currentColor">
                        <path
                            d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.791-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z" />
                    </svg>
                </a>
                <a href="https://www.instagram.com/analyticsdrive" target="_blank" aria-label="Instagram">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="currentColor">
                        <path
                            d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zM12 0C8.741 0 8.333.014 7.053.072 2.695.272.273 2.69.073 7.052.014 8.333 0 8.741 0 12c0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98C8.333 23.986 8.741 24 12 24c3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98C15.668.014 15.259 0 12 0zm0 5.838a6.162 6.162 0 100 12.324 6.162 6.162 0 000-12.324zM12 16a4 4 0 110-8 4 4 0 010 8zm6.406-11.845a1.44 1.44 0 100 2.881 1.44 1.44 0 000-2.881z" />
                    </svg>
                </a>
                <a href="https://www.reddit.com/r/Analyticsdrive/" target="_blank" aria-label="Reddit">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="currentColor">
                        <path
                            d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z" />
                    </svg>
                </a>
            </div>
        </div>
    </footer>

    <script>
        const toggleButton = document.getElementById('theme-toggle');
        const themeIcon = document.getElementById('theme-icon');
        const html = document.documentElement;

        // Check local storage or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme === 'dark' || (!savedTheme && systemDark)) {
            html.setAttribute('data-theme', 'dark');
            themeIcon.textContent = 'â˜€ï¸';
        }

        toggleButton.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            if (currentTheme === 'dark') {
                html.removeAttribute('data-theme');
                localStorage.setItem('theme', 'light');
                themeIcon.textContent = 'ðŸŒ™';
            } else {
                html.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
                themeIcon.textContent = 'â˜€ï¸';
            }
        });

        // --- External Link Hygiene ---
        // Adds rel="noopener noreferrer" + target="_blank" to all external links
        (function () {
            const siteHost = window.location.hostname;
            document.querySelectorAll('a[href^="http"]').forEach(function (link) {
                try {
                    const linkHost = new URL(link.href).hostname;
                    if (linkHost !== siteHost) {
                        link.setAttribute('rel', 'noopener noreferrer');
                        link.setAttribute('target', '_blank');
                    }
                } catch (e) { }
            });
        })();
    </script>

</body>

</html>