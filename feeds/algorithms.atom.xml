<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/"><title>Analytics Drive - Algorithms</title><link href="https://analyticsdrive.tech/" rel="alternate"/><link href="https://analyticsdrive.tech/feeds/algorithms.atom.xml" rel="self"/><id>https://analyticsdrive.tech/</id><updated>2026-02-23T14:04:00+00:00</updated><entry><title>Leetcode 127 Word Ladder: Master the BFS Approach Easily</title><link href="https://analyticsdrive.tech/leetcode-127-word-ladder-bfs-tutorial/" rel="alternate"/><published>2026-02-23T14:04:00+00:00</published><updated>2026-02-23T14:04:00+00:00</updated><author><name>Admin</name></author><id>tag:analyticsdrive.tech,2026-02-23:/leetcode-127-word-ladder-bfs-tutorial/</id><summary type="html">&lt;p&gt;Dive deep into Leetcode 127 Word Ladder with a comprehensive tutorial. Learn the Breadth-First Search (BFS) approach to solve this challenging problem.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Introduction to Leetcode 127 Word Ladder&lt;/h2&gt;
&lt;p&gt;Welcome to this in-depth tutorial where we'll explore &lt;strong&gt;Leetcode 127 Word Ladder&lt;/strong&gt;, a classic problem that masterfully combines graph theory with string manipulation. This challenge is frequently encountered in technical interviews and is an excellent way to solidify your understanding of Breadth-First Search (BFS). Our goal is to make it easy for you to master the BFS approach, providing clear steps and a robust Python implementation.&lt;/p&gt;
&lt;p&gt;The Word Ladder problem asks us to find the shortest transformation sequence from a &lt;code&gt;beginWord&lt;/code&gt; to an &lt;code&gt;endWord&lt;/code&gt;, given a dictionary &lt;code&gt;wordList&lt;/code&gt;. Each step in the transformation must change only one letter, and every intermediate word must exist in the &lt;code&gt;wordList&lt;/code&gt;. This problem inherently screams "shortest path in an unweighted graph," making BFS the perfect algorithm to tackle it efficiently. By the end of this guide, you'll not only understand the solution but also be able to implement it confidently.&lt;/p&gt;
&lt;h2&gt;Prerequisites for Solving Word Ladder&lt;/h2&gt;
&lt;p&gt;Before we dive deep into the solution for Leetcode 127 Word Ladder, it's beneficial to have a solid understanding of a few fundamental concepts. These prerequisites will ensure you can follow along with the logic and code without getting stuck on basics. Familiarity with these topics will significantly enhance your learning experience and your ability to apply the solution effectively.&lt;/p&gt;
&lt;p&gt;First, a good grasp of &lt;strong&gt;Breadth-First Search (BFS)&lt;/strong&gt; is essential. BFS is a graph traversal algorithm that explores all the neighbor nodes at the present depth level before moving on to the nodes at the next depth level. It's particularly suited for finding the shortest path in unweighted graphs, which is precisely what the Word Ladder problem requires. If you're new to BFS, a quick review of its mechanics, queues, and visited sets will be incredibly helpful. For a practical application of BFS in another challenging problem, check out our guide on &lt;a href="/01-matrix-problem-shortest-distance-bfs-dp-explained/"&gt;Unraveling the 01 Matrix: Finding the Nearest Zero with BFS and DP&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Second, an understanding of &lt;strong&gt;Graph Theory Basics&lt;/strong&gt; is crucial. The Word Ladder problem can be modeled as finding a path in an implicit graph where words are nodes and an edge exists between two words if they differ by exactly one letter. Knowing what nodes, edges, and paths represent in this context will make the solution much clearer. Exploring related graph algorithms, such as &lt;a href="/mastering-depth-first-search/"&gt;Mastering Depth-First Search (DFS)&lt;/a&gt;, can further solidify your understanding of graph traversal techniques. Concepts like adjacency are key to visualizing how words connect.&lt;/p&gt;
&lt;p&gt;Lastly, proficiency in &lt;strong&gt;Python Data Structures&lt;/strong&gt; such as lists, sets, and dictionaries (hash maps) will be very beneficial. We'll be using a queue for BFS, a set to keep track of visited words, and a dictionary to efficiently find potential neighbors. A basic understanding of string manipulation in Python will also be helpful for tasks like comparing words or generating generic states.&lt;/p&gt;
&lt;h2&gt;Understanding the Leetcode 127 Word Ladder Problem&lt;/h2&gt;
&lt;p&gt;The core of successfully solving any algorithmic problem lies in a thorough understanding of its statement, constraints, and examples. For &lt;strong&gt;Leetcode 127 Word Ladder&lt;/strong&gt;, the problem asks us to find the length of the shortest transformation sequence from a &lt;code&gt;beginWord&lt;/code&gt; to an &lt;code&gt;endWord&lt;/code&gt;. This transformation must adhere to specific rules: each adjacent word in the sequence must differ by exactly one letter, and every transformed word (except the &lt;code&gt;beginWord&lt;/code&gt;) must be present in a given &lt;code&gt;wordList&lt;/code&gt;. If no such transformation sequence exists, we should return 0.&lt;/p&gt;
&lt;p&gt;Let's consider an illustrative example to clarify the problem statement. Suppose &lt;code&gt;beginWord = "hit"&lt;/code&gt;, &lt;code&gt;endWord = "cog"&lt;/code&gt;, and &lt;code&gt;wordList = ["hot","dot","dog","lot","log","cog"]&lt;/code&gt;. We need to find the shortest sequence. A possible transformation could be:
&lt;code&gt;hit -&amp;gt; hot -&amp;gt; dot -&amp;gt; dog -&amp;gt; cog&lt;/code&gt;.
In this sequence, "hit" differs from "hot" by one letter, "hot" from "dot" by one, and so on, with all intermediate words (&lt;code&gt;hot&lt;/code&gt;, &lt;code&gt;dot&lt;/code&gt;, &lt;code&gt;dog&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;cog&lt;/code&gt;) existing in the &lt;code&gt;wordList&lt;/code&gt;. The length of this sequence is 5. We are looking for the &lt;em&gt;shortest&lt;/em&gt; such sequence.&lt;/p&gt;
&lt;p&gt;Key constraints and considerations for this problem include:
*   All words have the same length.
*   All words consist of lowercase English letters.
*   &lt;code&gt;beginWord&lt;/code&gt; and &lt;code&gt;endWord&lt;/code&gt; are non-empty and differ from each other.
*   &lt;code&gt;endWord&lt;/code&gt; &lt;em&gt;must&lt;/em&gt; be in &lt;code&gt;wordList&lt;/code&gt;. If it's not, no path exists, and the answer is 0. &lt;code&gt;beginWord&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; need to be in &lt;code&gt;wordList&lt;/code&gt;, but if it is, it can be part of the intermediate path. However, when we start the BFS, &lt;code&gt;beginWord&lt;/code&gt; acts as our initial node.
*   The &lt;code&gt;wordList&lt;/code&gt; contains distinct words.&lt;/p&gt;
&lt;p&gt;The goal is not to return the sequence itself, but its length. The &lt;code&gt;beginWord&lt;/code&gt; counts as one word in the sequence. Thus, if &lt;code&gt;beginWord = "a"&lt;/code&gt; and &lt;code&gt;endWord = "c"&lt;/code&gt; with &lt;code&gt;wordList = ["a", "b", "c"]&lt;/code&gt;, the sequence &lt;code&gt;a -&amp;gt; b -&amp;gt; c&lt;/code&gt; has a length of 3.&lt;/p&gt;
&lt;h2&gt;Why BFS is the Ideal Approach&lt;/h2&gt;
&lt;p&gt;When tackling the Leetcode 127 Word Ladder problem, the choice of algorithm is paramount, and Breadth-First Search (BFS) stands out as the ideal candidate. The primary reason for this is the problem's explicit requirement to find the &lt;em&gt;shortest&lt;/em&gt; transformation sequence. BFS inherently guarantees finding the shortest path in an unweighted graph, which perfectly aligns with this objective.&lt;/p&gt;
&lt;p&gt;Let's break down why BFS is so suitable here. Imagine each word in our &lt;code&gt;wordList&lt;/code&gt; (and the &lt;code&gt;beginWord&lt;/code&gt;) as a node in a graph. An edge exists between two nodes (words) if they differ by exactly one letter. Since each "step" or "transformation" has an equal "cost" (changing one letter), the graph is unweighted. BFS explores the graph layer by layer, expanding outwards from the starting node. This means it will always discover all nodes at depth &lt;code&gt;k&lt;/code&gt; before moving to any nodes at depth &lt;code&gt;k+1&lt;/code&gt;. Consequently, the first time it reaches the &lt;code&gt;endWord&lt;/code&gt;, it guarantees that this path is the shortest possible path from the &lt;code&gt;beginWord&lt;/code&gt; because all shorter paths (if they existed) would have been explored and completed at earlier depths.&lt;/p&gt;
&lt;p&gt;In contrast, Depth-First Search (DFS) would not be suitable for finding the shortest path directly. DFS explores as far as possible along each branch before backtracking. While DFS can find &lt;em&gt;a&lt;/em&gt; path, there's no guarantee it would be the shortest one without additional modifications (like tracking minimum length and exploring all paths, which essentially becomes dynamic programming or backtracking and is less efficient for shortest path in unweighted graphs). For instance, DFS might explore a very long branch before finding the &lt;code&gt;endWord&lt;/code&gt;, whereas BFS would immediately find the &lt;code&gt;endWord&lt;/code&gt; if it's reachable through a short sequence.&lt;/p&gt;
&lt;p&gt;Furthermore, BFS uses a queue structure, which naturally manages the exploration level by level. We can store &lt;code&gt;(word, level)&lt;/code&gt; pairs in the queue, incrementing the &lt;code&gt;level&lt;/code&gt; for each new layer of words we explore. This allows us to easily track the length of the transformation sequence as we traverse the graph. The moment we dequeue the &lt;code&gt;endWord&lt;/code&gt;, we know its associated &lt;code&gt;level&lt;/code&gt; represents the shortest path length.&lt;/p&gt;
&lt;h2&gt;Conceptualizing the Graph&lt;/h2&gt;
&lt;p&gt;To effectively apply BFS to the Leetcode 127 Word Ladder problem, we first need to clearly conceptualize the underlying graph structure. Although the problem doesn't explicitly give us an adjacency list or matrix, we can infer a graph where:
*   &lt;strong&gt;Nodes&lt;/strong&gt;: Each word in the &lt;code&gt;wordList&lt;/code&gt; (and the &lt;code&gt;beginWord&lt;/code&gt;) represents a node.
*   &lt;strong&gt;Edges&lt;/strong&gt;: An edge exists between two words if they differ by exactly one letter. This means they are "one-step transformable" from each other.&lt;/p&gt;
&lt;p&gt;The challenge lies in efficiently finding these edges. A naive approach would be to compare every word in the &lt;code&gt;wordList&lt;/code&gt; with every other word to check for a one-letter difference. This would be an &lt;code&gt;O(N^2 * L)&lt;/code&gt; operation to build the graph upfront, where &lt;code&gt;N&lt;/code&gt; is the number of words and &lt;code&gt;L&lt;/code&gt; is the length of each word. For larger &lt;code&gt;wordList&lt;/code&gt; sizes, this pre-processing can be prohibitively slow.&lt;/p&gt;
&lt;p&gt;A more optimized approach, often referred to as the "wildcard" or "generic state" method, allows us to find neighbors much more efficiently. Instead of comparing word pairs, we pre-process the &lt;code&gt;wordList&lt;/code&gt; to create a map (dictionary) where keys are "generic words" (words with one letter replaced by a wildcard, like &lt;code&gt;*&lt;/code&gt;) and values are lists of actual words that match that generic pattern.&lt;/p&gt;
&lt;p&gt;For example, if we have words like "hot", "dot", "lot", then:
*   &lt;code&gt;h*t&lt;/code&gt; would map to &lt;code&gt;["hot"]&lt;/code&gt;
*   &lt;code&gt;*ot&lt;/code&gt; would map to &lt;code&gt;["hot", "dot", "lot"]&lt;/code&gt;
*   &lt;code&gt;ho*&lt;/code&gt; would map to &lt;code&gt;["hot"]&lt;/code&gt;
*   &lt;code&gt;d*t&lt;/code&gt; would map to &lt;code&gt;["dot"]&lt;/code&gt;
*   &lt;code&gt;do*&lt;/code&gt; would map to &lt;code&gt;["dot"]&lt;/code&gt;
*   &lt;code&gt;l*t&lt;/code&gt; would map to &lt;code&gt;["lot"]&lt;/code&gt;
*   &lt;code&gt;lo*&lt;/code&gt; would map to &lt;code&gt;["lot"]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;When we are processing a &lt;code&gt;current_word&lt;/code&gt; (say, "hot"), we can generate all its &lt;code&gt;L&lt;/code&gt; generic patterns (&lt;code&gt;*ot&lt;/code&gt;, &lt;code&gt;h*t&lt;/code&gt;, &lt;code&gt;ho*&lt;/code&gt;). For each generic pattern, we look it up in our pre-processed map. The list of words associated with that generic pattern will give us all immediate neighbors that differ by one letter. This significantly speeds up neighbor discovery during the BFS, making it close to &lt;code&gt;O(L)&lt;/code&gt; for each word, rather than &lt;code&gt;O(N*L)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This &lt;code&gt;all_combo_dict&lt;/code&gt; (our wildcard dictionary) is critical for performance. It transforms the problem from repeatedly scanning the entire &lt;code&gt;wordList&lt;/code&gt; for neighbors to a simple dictionary lookup. We need to be careful with edge cases; for instance, the &lt;code&gt;beginWord&lt;/code&gt; might not be in the &lt;code&gt;wordList&lt;/code&gt;, but the &lt;code&gt;endWord&lt;/code&gt; must be. If &lt;code&gt;endWord&lt;/code&gt; is not in &lt;code&gt;wordList&lt;/code&gt;, no path is possible, and we can immediately return 0.&lt;/p&gt;
&lt;h2&gt;Step-by-Step Solution for Leetcode 127 Word Ladder&lt;/h2&gt;
&lt;p&gt;Let's walk through the detailed steps to implement the BFS solution for the Leetcode 127 Word Ladder problem. This structured approach will ensure clarity and help you understand the logic behind each part of the code.&lt;/p&gt;
&lt;h3&gt;Step 1: Initialize Data Structures and Validate Input&lt;/h3&gt;
&lt;p&gt;The first crucial step is to set up our environment and handle initial conditions. We need to ensure that the &lt;code&gt;endWord&lt;/code&gt; is actually reachable within the given &lt;code&gt;wordList&lt;/code&gt;. If &lt;code&gt;endWord&lt;/code&gt; is not present, no transformation is possible, so we can immediately return 0.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Word List to Set:&lt;/strong&gt; Convert &lt;code&gt;wordList&lt;/code&gt; into a &lt;code&gt;set&lt;/code&gt; for &lt;code&gt;O(1)&lt;/code&gt; average time complexity lookups. This is crucial for performance when checking if a word exists in the dictionary.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Queue for BFS:&lt;/strong&gt; Initialize a &lt;code&gt;deque&lt;/code&gt; (double-ended queue) from the &lt;code&gt;collections&lt;/code&gt; module. This will store tuples of &lt;code&gt;(word, level)&lt;/code&gt;, where &lt;code&gt;word&lt;/code&gt; is the current word being processed, and &lt;code&gt;level&lt;/code&gt; is its distance from &lt;code&gt;beginWord&lt;/code&gt;. Our BFS starts with &lt;code&gt;(beginWord, 1)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Visited Set:&lt;/strong&gt; Initialize another &lt;code&gt;set&lt;/code&gt; to keep track of words we have already visited. This prevents cycles and redundant processing, ensuring we find the shortest path and don't get stuck in loops. Mark &lt;code&gt;beginWord&lt;/code&gt; as visited from the start.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Step 2: Pre-process the Word List for Efficient Neighbor Lookups&lt;/h3&gt;
&lt;p&gt;This is the optimization step using "generic states" or "wildcard patterns." Instead of repeatedly generating neighbors by comparing words, we build an adjacency map beforehand.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;all_combo_dict&lt;/code&gt;:&lt;/strong&gt; Create a dictionary, let's call it &lt;code&gt;all_combo_dict&lt;/code&gt;.&lt;ul&gt;
&lt;li&gt;Iterate through every &lt;code&gt;word&lt;/code&gt; in the &lt;code&gt;word_set&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;For each &lt;code&gt;word&lt;/code&gt;, generate all possible "generic words" by replacing each of its letters with a wildcard character (e.g., &lt;code&gt;*&lt;/code&gt;). For a word "hot" of length &lt;code&gt;L=3&lt;/code&gt;, generate &lt;code&gt;*ot&lt;/code&gt;, &lt;code&gt;h*t&lt;/code&gt;, &lt;code&gt;ho*&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Store these generic words as keys in &lt;code&gt;all_combo_dict&lt;/code&gt;. The value for each key should be a list of actual words from &lt;code&gt;word_set&lt;/code&gt; that match this generic pattern.&lt;/li&gt;
&lt;li&gt;Example: If &lt;code&gt;word_set&lt;/code&gt; contains "hot", "dot", "lot", then &lt;code&gt;all_combo_dict['*ot']&lt;/code&gt; would eventually store &lt;code&gt;["hot", "dot", "lot"]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This pre-processing step creates an efficient lookup mechanism. When we need to find neighbors for a word &lt;code&gt;X&lt;/code&gt;, we just generate &lt;code&gt;L&lt;/code&gt; generic patterns for &lt;code&gt;X&lt;/code&gt;, and for each pattern, retrieve the list of matching words from &lt;code&gt;all_combo_dict&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Step 3: Start the Breadth-First Search Traversal&lt;/h3&gt;
&lt;p&gt;With our data structures initialized and our &lt;code&gt;all_combo_dict&lt;/code&gt; ready, we can now begin the core BFS algorithm.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Enqueue Initial State:&lt;/strong&gt; Add the &lt;code&gt;(beginWord, 1)&lt;/code&gt; tuple to our &lt;code&gt;queue&lt;/code&gt;. The &lt;code&gt;1&lt;/code&gt; represents the length of the sequence starting with &lt;code&gt;beginWord&lt;/code&gt; itself.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mark as Visited:&lt;/strong&gt; Immediately add &lt;code&gt;beginWord&lt;/code&gt; to our &lt;code&gt;visited&lt;/code&gt; set to prevent re-processing it.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Step 4: Process the Queue Until Empty&lt;/h3&gt;
&lt;p&gt;This is the main loop of our BFS. We continue as long as there are words in our queue to process.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dequeue Current Word:&lt;/strong&gt; In each iteration, &lt;code&gt;pop&lt;/code&gt; the leftmost element (FIFO) from the &lt;code&gt;queue&lt;/code&gt;. This element will be a &lt;code&gt;(current_word, level)&lt;/code&gt; tuple.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Check for End Word:&lt;/strong&gt; If &lt;code&gt;current_word&lt;/code&gt; is equal to &lt;code&gt;endWord&lt;/code&gt;, we've found the shortest path! Return &lt;code&gt;level&lt;/code&gt; immediately. Since BFS explores level by level, the first time &lt;code&gt;endWord&lt;/code&gt; is reached, it must be via the shortest possible sequence.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generate Neighbors:&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;For each character position &lt;code&gt;i&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;L-1&lt;/code&gt; (where &lt;code&gt;L&lt;/code&gt; is the length of &lt;code&gt;current_word&lt;/code&gt;):&lt;ul&gt;
&lt;li&gt;Create a &lt;code&gt;generic_word&lt;/code&gt; by replacing the character at position &lt;code&gt;i&lt;/code&gt; with a wildcard (&lt;code&gt;*&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Look up this &lt;code&gt;generic_word&lt;/code&gt; in &lt;code&gt;all_combo_dict&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;For every &lt;code&gt;neighbor_word&lt;/code&gt; in the list retrieved from &lt;code&gt;all_combo_dict&lt;/code&gt; for that &lt;code&gt;generic_word&lt;/code&gt;:&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Check Visited:&lt;/strong&gt; If &lt;code&gt;neighbor_word&lt;/code&gt; has not been visited (&lt;code&gt;neighbor_word&lt;/code&gt; not in &lt;code&gt;visited&lt;/code&gt;):&lt;ul&gt;
&lt;li&gt;Add &lt;code&gt;neighbor_word&lt;/code&gt; to the &lt;code&gt;visited&lt;/code&gt; set.&lt;/li&gt;
&lt;li&gt;Enqueue &lt;code&gt;(neighbor_word, level + 1)&lt;/code&gt; into the &lt;code&gt;queue&lt;/code&gt;. This indicates we've found a new word one step further in the transformation sequence.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Step 5: Handle No Path Found&lt;/h3&gt;
&lt;p&gt;If the &lt;code&gt;queue&lt;/code&gt; becomes empty, and we have not returned from the loop (meaning &lt;code&gt;endWord&lt;/code&gt; was never found), it signifies that there is no valid transformation sequence from &lt;code&gt;beginWord&lt;/code&gt; to &lt;code&gt;endWord&lt;/code&gt; under the given constraints. In this scenario, we should return 0.&lt;/p&gt;
&lt;p&gt;This step-by-step breakdown covers the entire logic for solving Leetcode 127 Word Ladder using BFS with the wildcard optimization. The next section will present the actual Python code implementation.&lt;/p&gt;
&lt;h2&gt;Python Code Implementation&lt;/h2&gt;
&lt;p&gt;Here's the complete Python implementation of the BFS solution for Leetcode 127 Word Ladder, incorporating all the steps discussed.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;deque&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;typing&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;ladderLength&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;beginWord&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;endWord&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wordList&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="c1"&gt;# Step 1: Validate Input and Initialize Data Structures&lt;/span&gt;
        &lt;span class="c1"&gt;# Convert wordList to a set for O(1) average time complexity lookups.&lt;/span&gt;
        &lt;span class="n"&gt;word_set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wordList&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# If endWord is not in the wordList, no transformation is possible.&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;endWord&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;word_set&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

        &lt;span class="c1"&gt;# Queue for BFS, storing (word, level) tuples.&lt;/span&gt;
        &lt;span class="c1"&gt;# Start with beginWord at level 1.&lt;/span&gt;
        &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;deque&lt;/span&gt;&lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;beginWord&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

        &lt;span class="c1"&gt;# Visited set to keep track of words already processed.&lt;/span&gt;
        &lt;span class="n"&gt;visited&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;beginWord&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;# Length of words. All words have the same length as per constraints.&lt;/span&gt;
        &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;beginWord&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# Step 2: Pre-process the Word List for Efficient Neighbor Lookups&lt;/span&gt;
        &lt;span class="c1"&gt;# all_combo_dict maps generic words (with a wildcard) to a list of actual words.&lt;/span&gt;
        &lt;span class="n"&gt;all_combo_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;word_set&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="c1"&gt;# Create a generic word by replacing the i-th char with &amp;#39;*&amp;#39;&lt;/span&gt;
                &lt;span class="n"&gt;generic_word&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;
                &lt;span class="c1"&gt;# Add the actual word to the list for this generic pattern&lt;/span&gt;
                &lt;span class="n"&gt;all_combo_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setdefault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generic_word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[])&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# Step 3 &amp;amp; 4: Start and Process the BFS Traversal&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;current_word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;popleft&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# Dequeue (word, level)&lt;/span&gt;

            &lt;span class="c1"&gt;# If current_word is the endWord, we found the shortest path.&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current_word&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;endWord&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt;

            &lt;span class="c1"&gt;# Generate all possible generic transformations for the current word&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="n"&gt;generic_word&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current_word&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;current_word&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;

                &lt;span class="c1"&gt;# Retrieve all actual words matching this generic pattern&lt;/span&gt;
                &lt;span class="c1"&gt;# from our pre-processed dictionary.&lt;/span&gt;
                &lt;span class="c1"&gt;# Use .get() with an empty list as default to handle cases&lt;/span&gt;
                &lt;span class="c1"&gt;# where a generic_word might not have any matches (e.g., if beginWord&lt;/span&gt;
                &lt;span class="c1"&gt;# creates a generic_word not matching any in word_set)&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;neighbor_word&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;all_combo_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generic_word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[]):&lt;/span&gt;
                    &lt;span class="c1"&gt;# If the neighbor word has not been visited yet,&lt;/span&gt;
                    &lt;span class="c1"&gt;# mark it as visited and enqueue it.&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;neighbor_word&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                        &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;neighbor_word&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                        &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;neighbor_word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

        &lt;span class="c1"&gt;# Step 5: Handle No Path Found&lt;/span&gt;
        &lt;span class="c1"&gt;# If the queue becomes empty and endWord was never reached, return 0.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Code Explanation:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;word_set = set(wordList)&lt;/code&gt;&lt;/strong&gt;: Converts the input list into a set. This allows for &lt;code&gt;O(1)&lt;/code&gt; average time complexity for checking word existence, which is critical for efficiency.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;if endWord not in word_set: return 0&lt;/code&gt;&lt;/strong&gt;: An early exit condition. If the target word isn't even in the dictionary, no transformation is possible.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;queue = deque([(beginWord, 1)])&lt;/code&gt;&lt;/strong&gt;: Initializes a &lt;code&gt;deque&lt;/code&gt; (from &lt;code&gt;collections&lt;/code&gt;) as our BFS queue. Each element is a tuple &lt;code&gt;(word, level)&lt;/code&gt;, where &lt;code&gt;level&lt;/code&gt; is the current path length. &lt;code&gt;beginWord&lt;/code&gt; is at level 1.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;visited = {beginWord}&lt;/code&gt;&lt;/strong&gt;: A set to keep track of words we've already processed. This prevents infinite loops and ensures we find the shortest path. &lt;code&gt;beginWord&lt;/code&gt; is immediately marked as visited.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;L = len(beginWord)&lt;/code&gt;&lt;/strong&gt;: Stores the length of the words, which is constant for all words in the problem.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;all_combo_dict = {}&lt;/code&gt;&lt;/strong&gt;: This dictionary is the core of our optimization.&lt;ul&gt;
&lt;li&gt;It's populated by iterating through every &lt;code&gt;word&lt;/code&gt; in &lt;code&gt;word_set&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;For each &lt;code&gt;word&lt;/code&gt;, it generates all &lt;code&gt;L&lt;/code&gt; possible "generic words" by replacing each character with an asterisk &lt;code&gt;*&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;These generic words are keys, and their values are lists of actual words that match that pattern. &lt;code&gt;setdefault&lt;/code&gt; is used to gracefully add words to lists.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;while queue:&lt;/code&gt;&lt;/strong&gt;: The main BFS loop. Continues as long as there are words to explore.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;current_word, level = queue.popleft()&lt;/code&gt;&lt;/strong&gt;: Extracts the word and its current level from the front of the queue.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;if current_word == endWord: return level&lt;/code&gt;&lt;/strong&gt;: If we've reached &lt;code&gt;endWord&lt;/code&gt;, this is the shortest path, so we return its &lt;code&gt;level&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;for i in range(L): generic_word = current_word[:i] + "*" + current_word[i+1:]&lt;/code&gt;&lt;/strong&gt;: This loop generates the &lt;code&gt;L&lt;/code&gt; generic patterns for the &lt;code&gt;current_word&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;for neighbor_word in all_combo_dict.get(generic_word, []):&lt;/code&gt;&lt;/strong&gt;: For each generic pattern, it looks up all potential &lt;code&gt;neighbor_word&lt;/code&gt;s from our pre-processed &lt;code&gt;all_combo_dict&lt;/code&gt;. &lt;code&gt;get(key, [])&lt;/code&gt; safely returns an empty list if the key doesn't exist.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;if neighbor_word not in visited:&lt;/code&gt;&lt;/strong&gt;: Checks if the neighbor has been processed. If not:&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;visited.add(neighbor_word)&lt;/code&gt;&lt;/strong&gt;: Marks it as visited.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;queue.append((neighbor_word, level + 1))&lt;/code&gt;&lt;/strong&gt;: Adds it to the queue for future processing, incrementing the &lt;code&gt;level&lt;/code&gt; as it's one step further.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;return 0&lt;/code&gt;&lt;/strong&gt;: If the loop finishes and &lt;code&gt;endWord&lt;/code&gt; was never found, it means no path exists.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This implementation effectively solves the Leetcode 127 Word Ladder problem by leveraging BFS and a clever pre-processing step for efficient neighbor discovery.&lt;/p&gt;
&lt;h2&gt;Complexity Analysis&lt;/h2&gt;
&lt;p&gt;Understanding the time and space complexity of an algorithm is crucial for evaluating its efficiency and suitability for various constraints. For the Leetcode 127 Word Ladder problem, our BFS approach with the wildcard optimization significantly improves performance compared to a naive graph construction.&lt;/p&gt;
&lt;p&gt;Let's define the variables:
*   &lt;code&gt;N&lt;/code&gt;: The number of words in the &lt;code&gt;wordList&lt;/code&gt;.
*   &lt;code&gt;L&lt;/code&gt;: The length of each word (all words have the same length).&lt;/p&gt;
&lt;h3&gt;Time Complexity&lt;/h3&gt;
&lt;p&gt;The overall time complexity can be broken down into two main phases: pre-processing and BFS traversal.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Pre-processing (&lt;code&gt;all_combo_dict&lt;/code&gt; construction):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We iterate through each of the &lt;code&gt;N&lt;/code&gt; words in the &lt;code&gt;word_set&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;For each word, we generate &lt;code&gt;L&lt;/code&gt; generic patterns (e.g., "hot" -&amp;gt; "&lt;em&gt;ot", "h&lt;/em&gt;t", "ho*"). Generating each generic pattern involves string slicing and concatenation, which takes &lt;code&gt;O(L)&lt;/code&gt; time.&lt;/li&gt;
&lt;li&gt;Storing these into the &lt;code&gt;all_combo_dict&lt;/code&gt; (which is a hash map) takes &lt;code&gt;O(1)&lt;/code&gt; on average per insertion (assuming good hash function distribution).&lt;/li&gt;
&lt;li&gt;Therefore, the total time for pre-processing is &lt;code&gt;N * L * O(L) = O(N * L^2)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BFS Traversal:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the worst-case scenario, every word in &lt;code&gt;word_set&lt;/code&gt; (including &lt;code&gt;beginWord&lt;/code&gt; if it's implicitly added to the graph) might be visited once. So, we process up to &lt;code&gt;N&lt;/code&gt; words.&lt;/li&gt;
&lt;li&gt;When we process a &lt;code&gt;current_word&lt;/code&gt; from the queue:&lt;ul&gt;
&lt;li&gt;We generate &lt;code&gt;L&lt;/code&gt; generic patterns for &lt;code&gt;current_word&lt;/code&gt;, each taking &lt;code&gt;O(L)&lt;/code&gt; time. So &lt;code&gt;O(L^2)&lt;/code&gt; to generate all patterns.&lt;/li&gt;
&lt;li&gt;For each generic pattern, we perform a dictionary lookup in &lt;code&gt;all_combo_dict&lt;/code&gt;. On average, this is &lt;code&gt;O(1)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The lookup returns a list of &lt;code&gt;neighbor_word&lt;/code&gt;s. The total work for iterating through these neighbors across all &lt;code&gt;L&lt;/code&gt; patterns is bounded by the total number of words that can be linked to &lt;code&gt;current_word&lt;/code&gt; via one-letter differences.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;More precisely, for each word &lt;code&gt;u&lt;/code&gt; (node) we visit:&lt;ul&gt;
&lt;li&gt;We generate &lt;code&gt;L&lt;/code&gt; generic patterns (&lt;code&gt;O(L)&lt;/code&gt; time for each, totaling &lt;code&gt;O(L^2)&lt;/code&gt; for all patterns generation if done naively for each word from scratch, or &lt;code&gt;O(L)&lt;/code&gt; if string building is optimized).&lt;/li&gt;
&lt;li&gt;For each pattern, we iterate over its neighbors. The sum of the lengths of all neighbor lists retrieved for a &lt;code&gt;current_word&lt;/code&gt; is equivalent to the degree of that word in the implicit graph.&lt;/li&gt;
&lt;li&gt;Since each word is processed once, and each edge in the graph is effectively traversed at most twice (once in each direction), the total cost for iterating through all neighbors across the entire BFS traversal is proportional to the total number of edges &lt;code&gt;E&lt;/code&gt; in our graph.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The total number of edges &lt;code&gt;E&lt;/code&gt; can be at most &lt;code&gt;N * L&lt;/code&gt;. For each of the &lt;code&gt;N&lt;/code&gt; words, we check &lt;code&gt;L&lt;/code&gt; generic patterns. Each &lt;code&gt;all_combo_dict&lt;/code&gt; lookup takes &lt;code&gt;O(1)&lt;/code&gt; average, and then we iterate through the list of words. The total number of times we append to the queue and update &lt;code&gt;visited&lt;/code&gt; is proportional to &lt;code&gt;V + E&lt;/code&gt;. Here, &lt;code&gt;V = N&lt;/code&gt; (number of words) and &lt;code&gt;E&lt;/code&gt; (number of connections) can be at most &lt;code&gt;N * L&lt;/code&gt; (as each word has &lt;code&gt;L&lt;/code&gt; generic patterns, each potentially connecting to other words).&lt;/li&gt;
&lt;li&gt;Therefore, the BFS traversal part is &lt;code&gt;O(N * L)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Combining pre-processing and BFS, the overall time complexity is &lt;code&gt;O(N * L^2 + N * L) = O(N * L^2)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Space Complexity&lt;/h3&gt;
&lt;p&gt;The space complexity is dominated by the storage of the &lt;code&gt;word_set&lt;/code&gt;, &lt;code&gt;queue&lt;/code&gt;, &lt;code&gt;visited&lt;/code&gt; set, and &lt;code&gt;all_combo_dict&lt;/code&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;word_set&lt;/code&gt;&lt;/strong&gt;: Stores &lt;code&gt;N&lt;/code&gt; words, each of length &lt;code&gt;L&lt;/code&gt;. &lt;code&gt;O(N * L)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;queue&lt;/code&gt;&lt;/strong&gt;: In the worst case, the queue can hold all &lt;code&gt;N&lt;/code&gt; words. &lt;code&gt;O(N * L)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;visited&lt;/code&gt; set&lt;/strong&gt;: Also stores up to &lt;code&gt;N&lt;/code&gt; words. &lt;code&gt;O(N * L)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;all_combo_dict&lt;/code&gt;&lt;/strong&gt;:&lt;ul&gt;
&lt;li&gt;Keys: There are &lt;code&gt;N&lt;/code&gt; words, and each word generates &lt;code&gt;L&lt;/code&gt; generic patterns. So, at most &lt;code&gt;N * L&lt;/code&gt; unique generic patterns (keys). Each key is of length &lt;code&gt;L&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Values: Each value is a list of words. The total number of words stored across all lists is &lt;code&gt;N * L&lt;/code&gt; (each word &lt;code&gt;w&lt;/code&gt; is added to the list of &lt;code&gt;L&lt;/code&gt; generic patterns it matches).&lt;/li&gt;
&lt;li&gt;Thus, the &lt;code&gt;all_combo_dict&lt;/code&gt; can consume &lt;code&gt;O(N * L^2)&lt;/code&gt; space. This is because there can be &lt;code&gt;O(N * L)&lt;/code&gt; generic keys (each of length L), and &lt;code&gt;O(N * L)&lt;/code&gt; entries in total across all value lists (each word is stored &lt;code&gt;L&lt;/code&gt; times in total).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Overall, the space complexity is &lt;code&gt;O(N * L^2)&lt;/code&gt;, primarily due to the &lt;code&gt;all_combo_dict&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In summary, this optimized BFS approach provides a robust solution with acceptable &lt;code&gt;O(N * L^2)&lt;/code&gt; time and space complexity, making it efficient for typical Leetcode constraints.&lt;/p&gt;
&lt;h2&gt;Common Mistakes and How to Avoid Them&lt;/h2&gt;
&lt;p&gt;Solving Leetcode 127 Word Ladder can be tricky, and several common pitfalls can lead to incorrect or inefficient solutions. Being aware of these mistakes can help you debug your code more effectively and write a robust solution from the outset.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Forgetting to Handle &lt;code&gt;endWord&lt;/code&gt; Not in &lt;code&gt;wordList&lt;/code&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mistake&lt;/strong&gt;: Proceeding with the BFS without checking if &lt;code&gt;endWord&lt;/code&gt; exists in the &lt;code&gt;wordList&lt;/code&gt;. If &lt;code&gt;endWord&lt;/code&gt; is not available, no path can ever reach it.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How to Avoid&lt;/strong&gt;: Always include an early check: &lt;code&gt;if endWord not in word_set: return 0&lt;/code&gt;. This is a quick win and handles a critical edge case.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Not Using a &lt;code&gt;visited&lt;/code&gt; Set&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mistake&lt;/strong&gt;: Failing to keep track of visited words. This will lead to infinite loops if cycles exist in the graph (e.g., &lt;code&gt;hot -&amp;gt; dot -&amp;gt; hot&lt;/code&gt;) or redundant re-processing of words, negating the "shortest path" guarantee of BFS.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How to Avoid&lt;/strong&gt;: Initialize a &lt;code&gt;visited&lt;/code&gt; set and add &lt;code&gt;beginWord&lt;/code&gt; to it. Before adding any &lt;code&gt;neighbor_word&lt;/code&gt; to the queue, always check &lt;code&gt;if neighbor_word not in visited:&lt;/code&gt; and then &lt;code&gt;visited.add(neighbor_word)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Incorrectly Calculating Path Length (Level)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mistake&lt;/strong&gt;: Off-by-one errors in determining the length of the transformation sequence. Some might start &lt;code&gt;beginWord&lt;/code&gt; at level 0, others might count edges instead of nodes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How to Avoid&lt;/strong&gt;: Be consistent. The problem asks for the &lt;em&gt;number of words&lt;/em&gt; in the shortest sequence. If &lt;code&gt;beginWord&lt;/code&gt; is level 1, then a path &lt;code&gt;beginWord -&amp;gt; word2 -&amp;gt; endWord&lt;/code&gt; has length &lt;code&gt;level_of_endWord&lt;/code&gt;. Sticking to &lt;code&gt;(beginWord, 1)&lt;/code&gt; and incrementing &lt;code&gt;level&lt;/code&gt; for each step is the clearest way. The &lt;code&gt;beginWord&lt;/code&gt; itself counts as the first word.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Inefficient Neighbor Generation (Brute-Force Word Comparison)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mistake&lt;/strong&gt;: In the BFS loop, iterating through the entire &lt;code&gt;wordList&lt;/code&gt; for &lt;em&gt;every&lt;/em&gt; &lt;code&gt;current_word&lt;/code&gt; to find words that differ by one character. This involves &lt;code&gt;O(N)&lt;/code&gt; comparisons, each taking &lt;code&gt;O(L)&lt;/code&gt; time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How to Avoid&lt;/strong&gt;: Implement the "wildcard" or "generic state" pre-processing step using &lt;code&gt;all_combo_dict&lt;/code&gt;. This reduces neighbor discovery from &lt;code&gt;O(N * L)&lt;/code&gt; to &lt;code&gt;O(L)&lt;/code&gt; (plus average lookup time).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Using DFS for Shortest Path&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mistake&lt;/strong&gt;: Attempting to use Depth-First Search (DFS) directly to find the &lt;em&gt;shortest&lt;/em&gt; path in an unweighted graph. DFS does not guarantee the shortest path without significant modifications (like explicit path tracking and comparing all paths), which makes it less suitable than BFS for this specific problem. If you wish to learn more about DFS, consult our detailed guide on &lt;a href="/mastering-depth-first-search/"&gt;Mastering Depth-First Search (DFS)&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How to Avoid&lt;/strong&gt;: Remember that BFS is the canonical algorithm for finding the shortest path in unweighted graphs. Its level-by-level exploration naturally yields the shortest path upon first reaching the target.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Modifying &lt;code&gt;wordList&lt;/code&gt; During Iteration&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mistake&lt;/strong&gt;: Removing words from the &lt;code&gt;wordList&lt;/code&gt; or &lt;code&gt;word_set&lt;/code&gt; while iterating over it (e.g., trying to use &lt;code&gt;wordList.remove(word)&lt;/code&gt; as a way to mark visited). This can lead to &lt;code&gt;RuntimeError: Set changed size during iteration&lt;/code&gt; or unexpected behavior.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How to Avoid&lt;/strong&gt;: Use a separate &lt;code&gt;visited&lt;/code&gt; set to manage visited states. The &lt;code&gt;word_set&lt;/code&gt; should remain immutable during the BFS traversal itself (after initial pre-processing).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;By keeping these common mistakes in mind, you can significantly streamline your problem-solving process for Leetcode 127 Word Ladder and similar graph traversal challenges.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We've embarked on a comprehensive journey through &lt;strong&gt;Leetcode 127 Word Ladder&lt;/strong&gt;, dissecting its problem statement, understanding the theoretical underpinnings, and implementing a robust, optimized solution. This problem serves as an excellent illustration of how to model real-world scenarios (or interview challenges) as graph problems and apply classic algorithms for efficient solutions.&lt;/p&gt;
&lt;p&gt;The core takeaway is the power of Breadth-First Search (BFS) in finding the shortest path within an unweighted graph. By conceptualizing words as nodes and one-letter differences as edges, BFS systematically explores the graph layer by layer, guaranteeing the discovery of the shortest transformation sequence first. Furthermore, we delved into a crucial optimization: using a pre-processed &lt;code&gt;all_combo_dict&lt;/code&gt; (wildcard dictionary) to drastically speed up neighbor discovery. This technique transforms a potentially &lt;code&gt;O(N*L)&lt;/code&gt; operation for finding neighbors into a much faster average &lt;code&gt;O(L)&lt;/code&gt; lookup, leading to an overall time complexity of &lt;code&gt;O(N * L^2)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We walked through each step, from initializing essential data structures like the queue and visited set, to building the efficient &lt;code&gt;all_combo_dict&lt;/code&gt;, and finally, executing the BFS traversal itself. The detailed Python code implementation provided a practical application of these concepts, ensuring you have a working solution ready for adaptation. We also highlighted common pitfalls, such as overlooking the &lt;code&gt;endWord&lt;/code&gt;'s presence in &lt;code&gt;wordList&lt;/code&gt; or inefficiently generating neighbors, empowering you to avoid these issues in your own problem-solving endeavors.&lt;/p&gt;
&lt;p&gt;Mastering problems like Leetcode 127 Word Ladder enhances not only your algorithmic skills but also your ability to analyze problem constraints, choose appropriate data structures, and optimize for performance. Keep practicing, and you'll find these patterns reappearing in various forms, ready for you to conquer with your newfound expertise.&lt;/p&gt;
&lt;h2&gt;Frequently Asked Questions&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Q: Why is BFS preferred over DFS for the Word Ladder problem?&lt;/strong&gt;
A: BFS is ideal because it guarantees finding the shortest path in unweighted graphs by exploring layer by layer. DFS, by contrast, explores depth-first and may find a longer path before eventually finding the shortest one, requiring more complex tracking.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q: What is the purpose of the &lt;code&gt;all_combo_dict&lt;/code&gt; (wildcard dictionary)?&lt;/strong&gt;
A: The &lt;code&gt;all_combo_dict&lt;/code&gt; is an optimization that pre-processes the &lt;code&gt;wordList&lt;/code&gt;. It maps generic word patterns (e.g., &lt;code&gt;h*t&lt;/code&gt;) to all actual words that match, allowing for &lt;code&gt;O(L)&lt;/code&gt; average time complexity to find neighbors instead of a brute-force &lt;code&gt;O(N*L)&lt;/code&gt; comparison.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q: Does the &lt;code&gt;beginWord&lt;/code&gt; need to be in the &lt;code&gt;wordList&lt;/code&gt;?&lt;/strong&gt;
A: No, &lt;code&gt;beginWord&lt;/code&gt; does not need to be in the &lt;code&gt;wordList&lt;/code&gt;. However, the &lt;code&gt;endWord&lt;/code&gt; &lt;em&gt;must&lt;/em&gt; be present in &lt;code&gt;wordList&lt;/code&gt; for a valid transformation path to exist, otherwise, the function should return 0.&lt;/p&gt;
&lt;h2&gt;Further Reading &amp;amp; Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Breadth-first_search"&gt;Breadth-First Search - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/word-ladder/"&gt;Word Ladder - LeetCode Problem 127&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Graph_theory"&gt;Graph Theory - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/collections.html#collections.deque"&gt;Python collections.deque documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="Algorithms"/><category term="Leetcode"/><category term="BFS"/><category term="Graph"/><category term="Algorithms"/><category term="Python"/><category term="DataStructures"/><media:content height="675" medium="image" type="image/webp" url="https://analyticsdrive.tech/images/leetcode-127-word-ladder-bfs-tutorial.webp" width="1200"/><media:title type="plain">Leetcode 127 Word Ladder: Master the BFS Approach Easily</media:title><media:description type="plain">Dive deep into Leetcode 127 Word Ladder with a comprehensive tutorial. Learn the Breadth-First Search (BFS) approach to solve this challenging problem.</media:description></entry><entry><title>Mastering Depth-First Search (DFS)</title><link href="https://analyticsdrive.tech/mastering-depth-first-search/" rel="alternate"/><published>2026-02-16T01:33:00+00:00</published><updated>2026-02-16T01:33:00+00:00</updated><author><name>Admin</name></author><id>tag:analyticsdrive.tech,2026-02-16:/mastering-depth-first-search/</id><summary type="html">&lt;p&gt;Dive deep into Depth-First Search (DFS), a fundamental graph traversal algorithm. Learn its mechanics, implementation, and powerful applications in programming.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Graphs are powerful tools for modeling relationships, from social networks to intricate computer systems. To make sense of these complex structures, we need efficient ways to explore them. Enter Depth-First Search (DFS), a fundamental algorithm that allows us to systematically traverse a graph.&lt;/p&gt;
&lt;p&gt;If you've ever gotten lost in a maze, always choosing to go as far as possible down one path before backtracking, you've intuitively performed a depth-first search! In this post, we'll unravel the mysteries of DFS, understanding how it works, how to implement it, and its vast applications.&lt;/p&gt;
&lt;h2&gt;What is Depth-First Search (DFS)?&lt;/h2&gt;
&lt;p&gt;Depth-First Search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root (or an arbitrary node) and explores as far as possible along each branch before backtracking. It's like exploring a labyrinth: you pick a path and follow it until you hit a dead end, then you retrace your steps to find an alternative route.&lt;/p&gt;
&lt;p&gt;This "go deep first" strategy contrasts with Breadth-First Search (BFS), which explores all immediate neighbors before moving to the next level of nodes. DFS prioritizes depth over breadth.&lt;/p&gt;
&lt;h2&gt;How DFS Works: The Core Mechanic&lt;/h2&gt;
&lt;p&gt;The fundamental idea behind DFS is quite simple:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Visit a node:&lt;/strong&gt; Start at an unvisited node.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mark as visited:&lt;/strong&gt; Keep track of visited nodes to avoid infinite loops in graphs with cycles.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Explore deeply:&lt;/strong&gt; For each unvisited neighbor of the current node, recursively call DFS on that neighbor.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Backtrack:&lt;/strong&gt; If all neighbors have been visited or there are no unvisited neighbors, backtrack to the previous node and explore other branches.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This process continues until all reachable nodes from the starting point have been visited.&lt;/p&gt;
&lt;h3&gt;A Walkthrough Example&lt;/h3&gt;
&lt;p&gt;Imagine a simple graph with nodes A, B, C, D, E.
Edges: (A, B), (A, C), (B, D), (C, E)&lt;/p&gt;
&lt;p&gt;Starting DFS from A:
1.  Visit A. Mark A as visited.
2.  Neighbors of A: B, C. Pick B.
3.  Visit B. Mark B as visited.
4.  Neighbors of B: D. Pick D.
5.  Visit D. Mark D as visited.
6.  Neighbors of D: None. Backtrack to B.
7.  All neighbors of B (D) visited. Backtrack to A.
8.  Neighbors of A: C (B already visited). Pick C.
9.  Visit C. Mark C as visited.
10. Neighbors of C: E. Pick E.
11. Visit E. Mark E as visited.
12. Neighbors of E: None. Backtrack to C.
13. All neighbors of C (E) visited. Backtrack to A.
14. All neighbors of A (B, C) visited. DFS complete.&lt;/p&gt;
&lt;p&gt;The order of traversal could be A -&amp;gt; B -&amp;gt; D -&amp;gt; C -&amp;gt; E. (Note: Order depends on neighbor processing order).&lt;/p&gt;
&lt;h2&gt;Implementing DFS&lt;/h2&gt;
&lt;p&gt;DFS can be implemented in two primary ways: recursively or iteratively using a stack. Both achieve the same result.&lt;/p&gt;
&lt;h3&gt;1. Recursive Implementation&lt;/h3&gt;
&lt;p&gt;The recursive approach is often more intuitive for DFS, directly mirroring the "explore deeply" principle.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;graph&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[],&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;visited&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# To keep track of visited nodes&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;dfs_recursive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# Process the node&lt;/span&gt;
        &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;neighbor&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
            &lt;span class="n"&gt;dfs_recursive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;neighbor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Recursive DFS Traversal:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;dfs_recursive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# Start DFS from node &amp;#39;A&amp;#39;&lt;/span&gt;
&lt;span class="c1"&gt;# Expected output: A B D C E&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2. Iterative Implementation (using a Stack)&lt;/h3&gt;
&lt;p&gt;Since recursion uses the call stack, we can manually manage a stack to achieve an iterative DFS.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;graph&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[],&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;dfs_iterative&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start_node&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;visited&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_node&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;Iterative DFS Traversal:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# Get the top node&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# Process the node&lt;/span&gt;
            &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="c1"&gt;# Add neighbors to stack in reverse order to ensure specific traversal order.&lt;/span&gt;
            &lt;span class="c1"&gt;# The last neighbor pushed will be the first one popped and explored.&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;neighbor&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;reversed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;]):&lt;/span&gt; 
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;neighbor&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;visited&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;neighbor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;dfs_iterative&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# Expected output: A C E B D (order might vary slightly based on neighbor pushing)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Characteristics of DFS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time Complexity&lt;/strong&gt;: For a graph with &lt;code&gt;V&lt;/code&gt; vertices and &lt;code&gt;E&lt;/code&gt; edges, DFS has a time complexity of O(V + E) because it visits each vertex and edge at most once.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space Complexity&lt;/strong&gt;: O(V) in the worst case (for the recursion stack or explicit stack), as it might need to store all vertices on the current path.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Completeness&lt;/strong&gt;: DFS is complete for finite graphs, meaning it will find a path to a goal state if one exists.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Optimality&lt;/strong&gt;: DFS is not optimal in general; it might find a longer path to a target simply because it explores one branch fully before exploring others.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Powerful Applications of DFS&lt;/h2&gt;
&lt;p&gt;DFS is more than just a traversal algorithm; it's a versatile tool used to solve a wide range of problems in computer science.&lt;/p&gt;
&lt;h3&gt;1. Finding Connected Components&lt;/h3&gt;
&lt;p&gt;In an undirected graph, DFS can easily identify all nodes belonging to the same connected component. If you start DFS from an unvisited node, all nodes reachable from it form a connected component.&lt;/p&gt;
&lt;h3&gt;2. Topological Sorting&lt;/h3&gt;
&lt;p&gt;For Directed Acyclic Graphs (DAGs), DFS can be used to produce a topological sort, which is a linear ordering of vertices such that for every directed edge U -&amp;gt; V, vertex U comes before V in the ordering. This is crucial for task scheduling.&lt;/p&gt;
&lt;h3&gt;3. Cycle Detection&lt;/h3&gt;
&lt;p&gt;DFS can detect cycles in both directed and undirected graphs. In an undirected graph, if DFS encounters a visited node that is not its immediate parent, a cycle exists. In a directed graph, a cycle is detected if DFS encounters a visited node that is currently in the recursion stack (i.e., an ancestor).&lt;/p&gt;
&lt;h3&gt;4. Pathfinding (Maze Solving)&lt;/h3&gt;
&lt;p&gt;DFS is a natural fit for solving mazes. By treating the maze as a graph where junctions are nodes and passages are edges, DFS can explore paths until it finds the exit.&lt;/p&gt;
&lt;h3&gt;5. Strongly Connected Components (Tarjan's, Kosaraju's Algorithms)&lt;/h3&gt;
&lt;p&gt;More advanced algorithms like Tarjan's or Kosaraju's for finding strongly connected components in directed graphs rely heavily on DFS.&lt;/p&gt;
&lt;h3&gt;6. Biconnectivity and Cut Vertices&lt;/h3&gt;
&lt;p&gt;DFS can identify articulation points (cut vertices) and bridges in a graph, which are critical for network reliability analysis.&lt;/p&gt;
&lt;h2&gt;DFS vs. BFS: When to Use Which?&lt;/h2&gt;
&lt;p&gt;While both DFS and BFS are fundamental graph traversal algorithms, their different strategies make them suitable for different scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DFS is preferred for:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cycle detection&lt;/li&gt;
&lt;li&gt;Topological sorting&lt;/li&gt;
&lt;li&gt;Finding connected components&lt;/li&gt;
&lt;li&gt;Pathfinding in unweighted graphs where &lt;em&gt;any&lt;/em&gt; path is sufficient (e.g., maze solving)&lt;/li&gt;
&lt;li&gt;When the graph is very deep and breadth-first search might consume too much memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BFS is preferred for:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Finding the shortest path in an unweighted graph&lt;/li&gt;
&lt;li&gt;Finding the minimum number of moves&lt;/li&gt;
&lt;li&gt;When the graph is very wide and shallow, and you need to find something close to the source.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Depth-First Search is a cornerstone algorithm in computer science, offering a powerful and elegant way to explore graph structures. Its "go deep" approach, whether implemented recursively or iteratively, provides solutions to a myriad of problems, from detecting cycles to orchestrating task dependencies. Understanding DFS not only sharpens your algorithmic thinking but also equips you with a versatile tool for tackling complex data relationships. So, the next time you encounter a graph problem, remember the deep dive power of DFS!&lt;/p&gt;
&lt;h2&gt;Further Reading &amp;amp; Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Depth-First Search (Wikipedia)&lt;/strong&gt;: &lt;a href="https://en.wikipedia.org/wiki/Depth-first_search"&gt;https://en.wikipedia.org/wiki/Depth-first_search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Graph Theory (Wikipedia)&lt;/strong&gt;: &lt;a href="https://en.wikipedia.org/wiki/Graph_theory"&gt;https://en.wikipedia.org/wiki/Graph_theory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Breadth-First Search (Wikipedia)&lt;/strong&gt;: &lt;a href="https://en.wikipedia.org/wiki/Breadth-first_search"&gt;https://en.wikipedia.org/wiki/Breadth-first_search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Topological Sorting (Wikipedia)&lt;/strong&gt;: &lt;a href="https://en.wikipedia.org/wiki/Topological_sorting"&gt;https://en.wikipedia.org/wiki/Topological_sorting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Strongly Connected Components (Wikipedia)&lt;/strong&gt;: &lt;a href="https://en.wikipedia.org/wiki/Strongly_connected_component"&gt;https://en.wikipedia.org/wiki/Strongly_connected_component&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="Algorithms"/><category term="DFS"/><category term="Algorithms"/><category term="Graph Theory"/><media:content height="675" medium="image" type="image/webp" url="https://analyticsdrive.tech/images/mastering-depth-first-search.webp" width="1200"/><media:title type="plain">Mastering Depth-First Search (DFS)</media:title><media:description type="plain">Dive deep into Depth-First Search (DFS), a fundamental graph traversal algorithm. Learn its mechanics, implementation, and powerful applications in programming.</media:description></entry><entry><title>Unraveling the 01 Matrix: Finding the Nearest Zero with BFS and DP</title><link href="https://analyticsdrive.tech/01-matrix-problem-shortest-distance-bfs-dp-explained/" rel="alternate"/><published>2026-02-13T15:40:00+00:00</published><updated>2026-02-13T15:40:00+00:00</updated><author><name>Admin</name></author><id>tag:analyticsdrive.tech,2026-02-13:/01-matrix-problem-shortest-distance-bfs-dp-explained/</id><summary type="html">&lt;p&gt;Master LeetCode's 01 Matrix problem (542) by finding the shortest distance to the nearest zero. Explore efficient solutions using Multi-Source BFS and Dynamic Programming.&lt;/p&gt;</summary><content type="html">&lt;p&gt;The "01 Matrix" problem (LeetCode 542) is a fundamental challenge that effectively tests your graph traversal and dynamic programming skills. Beyond a typical academic exercise, mastering such problems provides a robust foundation for tackling complex shortest path scenarios in real-world applications, spanning from image processing to logistics. In this post, we will dissect this intriguing problem, explore elegant solutions, and equip you with the knowledge to approach similar challenges confidently.&lt;/p&gt;
&lt;h2&gt;What is the 01 Matrix Problem?&lt;/h2&gt;
&lt;p&gt;The "01 Matrix" problem presents a binary matrix, meaning a grid filled with only &lt;code&gt;0&lt;/code&gt;s and &lt;code&gt;1&lt;/code&gt;s. Your task is to transform this matrix into one where each cell indicates the distance to its nearest &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Definition:&lt;/strong&gt; The "distance" between two adjacent cells (horizontally or vertically) is 1. We seek the shortest distance, often referred to as the Manhattan distance in a grid context.&lt;/p&gt;
&lt;p&gt;Let's illustrate with an example:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input Matrix:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[[0, 0, 0],
 [0, 1, 0],
 [0, 0, 0]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Expected Output Matrix:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[[0, 0, 0],
 [0, 1, 0],
 [0, 0, 0]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here, the &lt;code&gt;1&lt;/code&gt; at &lt;code&gt;(1,1)&lt;/code&gt; has a &lt;code&gt;0&lt;/code&gt; directly above, below, left, and right, so its shortest distance to a &lt;code&gt;0&lt;/code&gt; is 1. All &lt;code&gt;0&lt;/code&gt;s remain &lt;code&gt;0&lt;/code&gt; as their distance to themselves is 0.&lt;/p&gt;
&lt;p&gt;Another example:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input Matrix:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[[0, 1, 1],
 [1, 1, 1],
 [1, 1, 1]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Expected Output Matrix:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[[0, 1, 2],
 [1, 2, 3],
 [2, 3, 4]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Observe how distances increment as you move further away from the initial &lt;code&gt;0&lt;/code&gt;. This problem is essentially a shortest path problem on an unweighted graph where cells are nodes and adjacent cells are edges.&lt;/p&gt;
&lt;h2&gt;Approach 1: Multi-Source Breadth-First Search (BFS)&lt;/h2&gt;
&lt;p&gt;BFS is a natural fit for finding the shortest path in an unweighted graph. A key insight here is the presence of &lt;em&gt;multiple&lt;/em&gt; sources (all the &lt;code&gt;0&lt;/code&gt;s) from which distances propagate.&lt;/p&gt;
&lt;h3&gt;The Core Idea&lt;/h3&gt;
&lt;p&gt;Instead of starting BFS from a single source, we initialize our queue with &lt;em&gt;all&lt;/em&gt; the cells that contain a &lt;code&gt;0&lt;/code&gt;. These cells already have a distance of 0. Then, we expand outwards layer by layer, propagating outwards in a layered fashion. Each time we move to an unvisited neighbor, we know its distance is one more than the current cell's distance.&lt;/p&gt;
&lt;h3&gt;Step-by-Step Breakdown&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Initialize &lt;code&gt;dist&lt;/code&gt; Matrix:&lt;/strong&gt; Create a result matrix &lt;code&gt;dist&lt;/code&gt; of the same dimensions as the input matrix.&lt;ul&gt;
&lt;li&gt;For cells with &lt;code&gt;0&lt;/code&gt; in the input, set &lt;code&gt;dist[r][c] = 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;For cells with &lt;code&gt;1&lt;/code&gt; in the input, set &lt;code&gt;dist[r][c] = -1&lt;/code&gt; (or &lt;code&gt;infinity&lt;/code&gt;) to mark them as unvisited and to be calculated.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Initialize Queue:&lt;/strong&gt; Create a queue and add all &lt;code&gt;(r, c)&lt;/code&gt; coordinates where &lt;code&gt;matrix[r][c] == 0&lt;/code&gt;. These are our starting points.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BFS Traversal:&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;While the queue is not empty:&lt;ul&gt;
&lt;li&gt;Dequeue a cell &lt;code&gt;(r, c)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;For each of its four neighbors &lt;code&gt;(nr, nc)&lt;/code&gt; (up, down, left, right):&lt;ul&gt;
&lt;li&gt;Check if &lt;code&gt;(nr, nc)&lt;/code&gt; is within bounds.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;dist[nr][nc]&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; (indicating it's an unvisited &lt;code&gt;1&lt;/code&gt;):&lt;ul&gt;
&lt;li&gt;Set &lt;code&gt;dist[nr][nc] = dist[r][c] + 1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Enqueue &lt;code&gt;(nr, nc)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Return &lt;code&gt;dist&lt;/code&gt;:&lt;/strong&gt; The &lt;code&gt;dist&lt;/code&gt; matrix now contains the shortest distances.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Python Code Example (Multi-Source BFS)&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;deque&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;updateMatrixBFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;dist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;deque&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="c1"&gt;# Initialize dist matrix and queue with all 0s&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;dist&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
                &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;# Directions for neighbors (up, down, left, right)&lt;/span&gt;
    &lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;popleft&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;dr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dc&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;directions&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;nr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dc&lt;/span&gt;

            &lt;span class="c1"&gt;# Check bounds and if neighbor is unvisited (value is -1)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;nr&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;nc&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;nr&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;nc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;dist&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;nr&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;nc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;nr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nc&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;

&lt;span class="c1"&gt;# Example usage:&lt;/span&gt;
&lt;span class="n"&gt;matrix1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;updateMatrixBFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrix1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;# Expected: [[0, 1, 2], [1, 2, 3], [2, 3, 4]]&lt;/span&gt;

&lt;span class="n"&gt;matrix2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;updateMatrixBFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrix2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;# Expected: [[0, 0, 0], [0, 1, 0], [0, 0, 0]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Complexity Analysis (BFS)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time Complexity:&lt;/strong&gt; O(M * N), where M is the number of rows and N is the number of columns. Each cell is added to the queue and processed at most once.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space Complexity:&lt;/strong&gt; O(M * N) for the &lt;code&gt;dist&lt;/code&gt; matrix and, in the worst case, the queue can hold all cells (e.g., a matrix of all &lt;code&gt;0&lt;/code&gt;s or all &lt;code&gt;1&lt;/code&gt;s).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Approach 2: Dynamic Programming (DP)&lt;/h2&gt;
&lt;p&gt;While BFS is intuitive for shortest paths, dynamic programming offers an alternative perspective, especially useful in grid problems where dependencies are directional. The core principle is that a cell's distance to the nearest &lt;code&gt;0&lt;/code&gt; depends on its neighbors' distances.&lt;/p&gt;
&lt;p&gt;The challenge is that you cannot access all neighbors simultaneously if you are building up the solution. We solve this by doing &lt;em&gt;two passes&lt;/em&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;First Pass (Top-Left to Bottom-Right):&lt;/strong&gt; For each cell, we consider its distance from &lt;code&gt;0&lt;/code&gt;s that are &lt;em&gt;above&lt;/em&gt; or to its &lt;em&gt;left&lt;/em&gt;.
    &lt;code&gt;dp[r][c] = min(dp[r][c], dp[r-1][c] + 1, dp[r][c-1] + 1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Second Pass (Bottom-Right to Top-Left):&lt;/strong&gt; For each cell, we then refine its distance by considering &lt;code&gt;0&lt;/code&gt;s that are &lt;em&gt;below&lt;/em&gt; or to its &lt;em&gt;right&lt;/em&gt;.
    &lt;code&gt;dp[r][c] = min(dp[r][c], dp[r+1][c] + 1, dp[r][c+1] + 1)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Step-by-Step Breakdown&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Initialize &lt;code&gt;dp&lt;/code&gt; Matrix:&lt;/strong&gt; Create a &lt;code&gt;dp&lt;/code&gt; matrix of the same dimensions.&lt;ul&gt;
&lt;li&gt;If &lt;code&gt;matrix[r][c] == 0&lt;/code&gt;, set &lt;code&gt;dp[r][c] = 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;matrix[r][c] == 1&lt;/code&gt;, set &lt;code&gt;dp[r][c]&lt;/code&gt; to a sufficiently large value (effectively infinity) to represent an unknown, maximum distance.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;First Pass (Top-Left to Bottom-Right):&lt;/strong&gt; Iterate &lt;code&gt;r&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;m-1&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt;.&lt;ul&gt;
&lt;li&gt;For &lt;code&gt;dp[r][c]&lt;/code&gt;, if it's not already 0:&lt;ul&gt;
&lt;li&gt;If &lt;code&gt;r &amp;gt; 0&lt;/code&gt;, &lt;code&gt;dp[r][c] = min(dp[r][c], dp[r-1][c] + 1)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;c &amp;gt; 0&lt;/code&gt;, &lt;code&gt;dp[r][c] = min(dp[r][c], dp[r][c-1] + 1)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Second Pass (Bottom-Right to Top-Left):&lt;/strong&gt; Iterate &lt;code&gt;r&lt;/code&gt; from &lt;code&gt;m-1&lt;/code&gt; down to &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; from &lt;code&gt;n-1&lt;/code&gt; down to &lt;code&gt;0&lt;/code&gt;.&lt;ul&gt;
&lt;li&gt;For &lt;code&gt;dp[r][c]&lt;/code&gt;, if it's not already 0:&lt;ul&gt;
&lt;li&gt;If &lt;code&gt;r &amp;lt; m-1&lt;/code&gt;, &lt;code&gt;dp[r][c] = min(dp[r][c], dp[r+1][c] + 1)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;c &amp;lt; n-1&lt;/code&gt;, &lt;code&gt;dp[r][c] = min(dp[r][c], dp[r][c+1] + 1)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Return &lt;code&gt;dp&lt;/code&gt;:&lt;/strong&gt; The &lt;code&gt;dp&lt;/code&gt; matrix now holds the shortest distances.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Python Code Example (Dynamic Programming)&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;updateMatrixDP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

    &lt;span class="c1"&gt;# Initialize dp matrix with a large value for 1s, 0 for 0s&lt;/span&gt;
    &lt;span class="c1"&gt;# Using m*n as max possible distance (can be optimized to m+n)&lt;/span&gt;
    &lt;span class="n"&gt;max_dist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; 
    &lt;span class="n"&gt;dp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;max_dist&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="c1"&gt;# Check top neighbor&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="c1"&gt;# Check left neighbor&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Second pass: bottom-right to top-left&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="c1"&gt;# Check bottom neighbor&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="c1"&gt;# Check right neighbor&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;dp&lt;/span&gt;

&lt;span class="c1"&gt;# Example usage:&lt;/span&gt;
&lt;span class="n"&gt;matrix1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;updateMatrixDP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrix1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;# Expected: [[0, 1, 2], [1, 2, 3], [2, 3, 4]]&lt;/span&gt;

&lt;span class="n"&gt;matrix2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;updateMatrixDP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrix2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;# Expected: [[0, 0, 0], [0, 1, 0], [0, 0, 0]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Complexity Analysis (DP)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time Complexity:&lt;/strong&gt; O(M * N). We iterate through the matrix twice.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space Complexity:&lt;/strong&gt; O(M * N) for the &lt;code&gt;dp&lt;/code&gt; matrix.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;BFS vs. DP: Which One to Choose?&lt;/h2&gt;
&lt;p&gt;Both BFS and DP provide correct and efficient solutions with the same time and space complexity for this particular problem.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BFS:&lt;/strong&gt; Often more intuitive for shortest path problems on unweighted graphs. It guarantees finding the shortest path first because it expands layer by layer. The multi-source aspect is handled elegantly.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DP:&lt;/strong&gt; Requires a bit more thought with the two-pass approach to ensure all dependencies (from all four directions) are covered. However, DP can sometimes be more flexible or adaptable for problems with slightly different constraints or for calculating values beyond just "shortest path."&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the 01 Matrix problem, the Multi-Source BFS is generally considered the more straightforward and natural approach. However, understanding the DP solution broadens your algorithmic toolkit.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The "01 Matrix" problem (LeetCode 542) is an excellent exercise to solidify your understanding of graph traversal algorithms like Breadth-First Search and dynamic programming. Whether you prefer the elegant ripple effect of a multi-source BFS or the methodical two-pass calculation of DP, both methods lead you to the correct shortest distances to the nearest &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;By mastering problems like this, you are not just solving a LeetCode puzzle; you are building a strong foundation in algorithmic thinking that is invaluable for any coding challenge or real-world system design task. Continue to practice, explore, and enhance your algorithmic proficiency.&lt;/p&gt;</content><category term="Algorithms"/><category term="01 Matrix"/><category term="BFS"/><category term="Dynamic Programming"/><category term="LeetCode"/><category term="Shortest Path"/><category term="Graph Algorithms"/><media:content height="675" medium="image" type="image/webp" url="https://analyticsdrive.tech/images/01-matrix-problem-shortest-distance-bfs-dp-explained.webp" width="1200"/><media:title type="plain">Unraveling the 01 Matrix: Finding the Nearest Zero with BFS and DP</media:title><media:description type="plain">Master LeetCode's 01 Matrix problem (542) by finding the shortest distance to the nearest zero. Explore efficient solutions using Multi-Source BFS and Dynamic Programming.</media:description></entry></feed>